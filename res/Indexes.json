[{"q":"<p>A merge table operation needs to be performed between two tables. In the given context, select the checks that must be satisfied by the indexes used in these tables?</p>\n\n<p>1. Index part lengths must be equal</p>\n\n<p>2. Index part types must be equal</p>\n\n<p>3. Index part languages must be equal</p>\n\n<p>4. Verify whether index parts can be NULL.</p>\n\n<p><em>Note:</em> Assume that you are working on MySQL.</p>","a":[{"id":1619227,"option":"Only 1,2","correct":false},{"id":1619228,"option":"Only 2,3","correct":false},{"id":1619229,"option":"Only 2,3,4","correct":false},{"id":1619230,"option":"Only 1,2,3","correct":false},{"id":1619231,"option":"All 1,2,3,4","correct":true}]},{"q":"<p>You have a FULLTEXT query that takes only TOP N matching rows after sorting the rows in descending order and applying a LIMIT clause to it. Which of the following must be there in order to apply this optimization?</p>\n\n<p><em>Note:</em> Assume that you are working on MySQL.</p>","a":[{"id":1619219,"option":"WHERE clause","correct":false},{"id":1619220,"option":"A single ORDER BY clause in descending order","correct":true},{"id":1619221,"option":"WHERE clause and a single ORDER BY clause in descending order","correct":false},{"id":1619222,"option":"WHERE clause and a single ORDER BY clause in ascending order","correct":false}]},{"q":"<p>You want to bypass existing index key limits and execute fully covered, indexed, queries when working with Nonclustered indexes in SQL. What should you do to achieve this?</p>\n\n<p><em>Note:</em> Assume that you are working on MS/SQL server.</p>","a":[{"id":1619211,"option":"Add a nonkey columns to the leaf level of the nonclustered index","correct":true},{"id":1619212,"option":"Add a pointer from an index row in a nonclustered index","correct":false},{"id":1619213,"option":"Add a row locator to the leaf level of the nonclustered index","correct":false},{"id":1619214,"option":"Add a UNIQUE constraint on the table","correct":false}]},{"q":"<p>You are trying to enforce a PRIMARY KEY constraint on an existing table 'T1'. It is given that a clustered index already exists on the table 'T1'. What does the SQL server do in the given scenario?</p>\n\n<p><em>Note:</em> Assume that you are working on MS/SQL server.</p>","a":[{"id":1619207,"option":"It enforces the primary key using a nonclustered index.","correct":true},{"id":1619208,"option":"It throws an error","correct":false},{"id":1619209,"option":"It automatically created a automatically creates a nonclustered index","correct":false},{"id":1619210,"option":"Cannot be determined","correct":false}]},{"q":"<p>You want to create a unique index per table that uses the primary key to organize the data that is within the table. What can be achieved by creating such a cluster?</p>","a":[{"id":1616910,"option":"You can ensure that the primary key is stored in increasing order","correct":false},{"id":1616911,"option":"You do not have to explicitly declare such a cluster","correct":false},{"id":1616912,"option":"Both 1 and 2","correct":true},{"id":1616913,"option":"None of these","correct":false}]},{"q":"<p>You want to rename a particular index in your database. Which of the following can be used to achieve this?</p>","a":[{"id":1616906,"option":"The system stored procedure sp_rename","correct":true},{"id":1616907,"option":"ALTER INDEX","correct":false},{"id":1616908,"option":"ALTER INDEXNAME","correct":false},{"id":1616909,"option":"CREATE INDEXNAME","correct":false}]},{"q":"<p>You have decided to use indexes to enhance the performance of your database. In which of the given situations should you reconsider using indexes?</p>\n\n<p>1. You are working with tables that have a column with a wide range of values.</p>\n\n<p>2. You have a table with frequent, large batch updates or insert operations.</p>\n\n<p>3. You are working on tables with columns that are frequently manipulated.</p>","a":[{"id":1616902,"option":"Only 2 and 3","correct":true},{"id":1616903,"option":"Only 1 and 3","correct":false},{"id":1616904,"option":"Only 1 and 2","correct":false},{"id":1616905,"option":"All 1, 2 and 3","correct":false}]},{"q":"<p>You want to use an index in your SQL table to improve performance as well as maintain data integrity (maintain distinct values). Which of these indexes can you use to achieve this?</p>\n\n<p> </p>","a":[{"id":1616884,"option":"CREATE UNIQUE INDEX Cust_Ind on Customer (Cust_Name);","correct":true},{"id":1616885,"option":"CREATE INDEX Cust_Ind on Customer (Cust_Name);","correct":false},{"id":1616886,"option":"Both 1 and 2","correct":false},{"id":1616887,"option":"Neither 1 nor 2","correct":false}]},{"q":"<p>You want to use a set of indexes to perform the following set operations in MS/SQL</p>\n\n<p>A. Indexes are used for searching a set of columns for a single value.</p>\n\n<p>B. Indexes are to be used for operations on columns with high selectivity.</p>\n\n<p>Select the kind of indexes that will be appropriate for usage in these situations from the given choices.</p>","a":[{"id":1616876,"option":"A. Clustered ,B. Nonclustered","correct":false},{"id":1616877,"option":"A. Clustered ,B. Clustered","correct":false},{"id":1616878,"option":"A. Nonclustered,B. Nonclustered","correct":true},{"id":1616879,"option":"A. Nonclustered,B. Clustered","correct":false}]},{"q":"<p>You are using indexes on your tables to speed up data retrievals from your database. What can be said about the given deductions in the given scenario?</p>\n\n<p>D1: An index can help speed up SELECT queries and WHERE clauses</p>\n\n<p>D2: An index can help speed up UPDATE and the INSERT statements</p>","a":[{"id":1616872,"option":"Only D1 is true","correct":true},{"id":1616873,"option":"Only D2 is true","correct":false},{"id":1616874,"option":"Both D1 and D2 are true","correct":false},{"id":1616875,"option":"Neither D1 nor D2 are true","correct":false}]},{"q":"<p>You want to delete an index 'Cust_Ind' used in a MySQL table named 'Cust_Det'. Which of these queries can you use to achieve this?</p>\n\n<p> </p>","a":[{"id":1616868,"option":"ALTER TABLE Cust_Det ,DROP INDEX Cust_Ind;","correct":true},{"id":1616869,"option":"DROP INDEX Cust_Ind;","correct":false},{"id":1616870,"option":"DROP INDEX Cust_Det.Cust_Ind;","correct":false},{"id":1616871,"option":"DROP INDEX Cust_Ind FROM Cust_Det;","correct":false}]},{"q":"<p>Which of the following SQL query will create an appropriate non-clustered index on the Cake_ID column of the OrdersTbl table shown alongside?</p>\n\n<pre class=\"prettyprint\"><code>CREATE TABLE OrdersTbl\n(\n Id INT,\n CustomerId INT,\nCakeId Varchar(100),\nCakeFlavor VARCHAR(50)\n)\nGO</code></pre>\n\n<p><strong>options:</strong></p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>CREATE NONCLUSTERED INDEX IX_OrdersTbl _CakeId\nON dbo.OrdersTbl(CakeId)\nINCLUDE ([Id],[CustomerId],[CakeFlavor])\nGO</code></pre>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>CREATE NONCLUSTERED INDEX IX_OrdersTbl _Cake_ID\nON dbo.OrdersTbl(Customer_ID)\nINCLUDE ([Id],[Cake_ID],[CakeFlavor])\nGO</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>CREATE NONCLUSTERED INDEX IX_OrdersTbl _Cake_ID\nON dbo.OrdersTbl(Cake_ID)\nBEGIN\nINCLUDE ([Id],[Customer_ID],[CakeFlavor])\nEND</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>CREATE NONCLUSTERED INDEX IX_OrdersTbl _Customer_ID\nON dbo.OrdersTbl(Cake_ID)\nINCLUDE ([Cake_ID],[Customer_ID],[CakeFlavor])\nGO</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":1616864,"option":"1","correct":true},{"id":1616865,"option":"2","correct":false},{"id":1616866,"option":"3","correct":false},{"id":1616867,"option":"4","correct":false}]},{"q":"<p>You have two tables STUDENTS and DEPARTMENTS, having millions of records with only 15 distinct values. In the given scenario, what type of SQL index can you use instead of a normal query to improve the performance when fetching data from the tables?</p>","a":[{"id":1616860,"option":"Unique Index","correct":false},{"id":1616861,"option":"Clustered Index","correct":false},{"id":1616862,"option":"Bit-map Index","correct":true},{"id":1616863,"option":"Non-clustered Index","correct":false}]},{"q":"<p>You want to drop a particular index from your data dictionary. Which of these is a necessary condition to achieve this?</p>","a":[{"id":1616856,"option":"You must be the owner of the index","correct":false},{"id":1616857,"option":"You must have the DROP ANY INDEX privilege","correct":false},{"id":1616858,"option":"Both 1 and 2","correct":false},{"id":1616859,"option":"Either 1 or 2","correct":true}]},{"q":"<p>You have a collection named 'users' in a database 'friendschat'. The collection has numerous documents archived in it. The snapshot for one of its documents is given below. For faster querying on the data, you need to apply an index to the collection.<br>\n<strong>Document:</strong><br>\n{  _id: ObjectId(\"523cba3c73a8049bcdbf6007\"),  name: 'Amruta Shinde', age: 26, nationality: \"India\", address: { city: \"Mumbai\" },</p>\n\n<p>Get the all indexes that are already created on a collection 'users'. Create an index on a collection 'books' using the field 'city'. Also, create a compound index using the fields 'name' and 'age'. You need to get the results sorted first by name in ascending order and then by age in descending order.<br>\nWhich of the following will perform these operations successfully?</p>\n\n<p><strong>Options</strong></p>\n\n<p>1.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use friendschat\n&gt; db.users.geAllIndexes()\n&gt; db.products.createIndex( { \"address[\"city\"]\":1 } )\n&gt; db.products.createIndex( { \"name_age\": 1 } )\n&gt; db.events.find().sort( { name: asc},{ age: desc } )</code></pre>\n\n<p>2.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use friendschat\n&gt; db.users.find().Indexes()\n&gt; db.products.createIndex( { \"address&gt;city\":1 } )\n&gt; db.products.createIndex( { \"name\": 1 + \"age\": 1 } )\n&gt; db.events.find().sort( [ name: 1, age: -1 ] )</code></pre>\n\n<p>3.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use friendschat\n&gt; db.users.getIndexes()\n&gt; db.products.createIndex( { \"\\address\\city\\\":1 } )\n&gt; db.products.createIndex( { \"name\": 1, \"age\": 1 } )\n&gt; db.events.find().sort( { name: asc, age: desc } )</code></pre>\n\n<p>4.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use friendschat\n&gt; db.users.getIndexes()\n&gt; db.products.createIndex( { \"address.city\":1 } )\n&gt; db.products.createIndex( { \"name\": 1, \"age\": 1 } )\n&gt; db.events.find().sort( { name: 1, age: -1 } )</code></pre>\n\n<p> </p>","a":[{"id":1652505,"option":"1","correct":false},{"id":1652506,"option":"2","correct":false},{"id":1652507,"option":"3","correct":false},{"id":1652508,"option":"4","correct":true}]},{"q":"<p>You have a collection named 'books' in a database 'library'. The collection has numerous documents archived in it. The snapshot for a few documents from this collection is given below.<br>\n<strong>Collection:</strong> books<br>\n{ \"_id\" : ObjectId(\"60cb59a41c3423c6cd1188cb\"), \"book_id\" : \"5432\", \"name\" : \"Learning Python\", \"author\":\"David Smith\"}<br>\n{ \"_id\" : ObjectId(\"60cb59a41c3423c6cd1188cb\"), \"book_id\" : \"100002\", \"name\" : \"Head first Python\", \"author\":\"Scott Meyer\"}</p>\n\n<p>For efficient searching of the data, you need to create an index on a collection 'books' using the field 'book_id' and then remove the index.</p>\n\n<p>Which of the following options will perform these operations successfully?</p>\n\n<p><strong>Options</strong></p>\n\n<p>1.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use library\n&gt; db.products.ensureIndex(\"book_id\")\n&gt; db.products.deleteIndex(\"book_id\")</code></pre>\n\n<p>2.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use library\n&gt; db.products.createIndex( { \"book_id\": 1 } )\n&gt; db.products.dropIndex( { \"book_id\": 1 } )</code></pre>\n\n<p>3.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use library\n&gt; db.products.createIndex( { \"book_id\": -1 } )\n&gt; db.products.deleteIndex( { \"book_id\": -1 } )</code></pre>\n\n<p>4.</p>\n\n<pre class=\"prettyprint\"><code>&gt; use library\n&gt; db.products.newIndex( {\"book_id\"} )\n&gt; db.products.dropIndex( {\"book_id\"} )</code></pre>\n\n<p> </p>","a":[{"id":1652501,"option":"1","correct":false},{"id":1652502,"option":"2","correct":true},{"id":1652503,"option":"3","correct":false},{"id":1652504,"option":"4","correct":false}]},{"q":"<p>In SQL Server, which of the following statements is correct about an aligned index?<br>\n<br>\n<strong>Statements</strong></p>\n\n<ol>\n\t<li>If a table and its indexes are aligned, MS SQL Server switches in between the partition structure of both the table and its indexes for quick and efficient data maintenance.<br>\n\t </li>\n\t<li>An index has to be in the same partition function if you have to align it with the base table.<br>\n\t </li>\n\t<li>The alignment between the partition table and partition index will follow the same partition function in terms of arguments, data types, and the number of partitions.</li>\n</ol>","a":[{"id":382007,"option":"1,2, and 3","correct":false},{"id":382008,"option":"1, 3","correct":true},{"id":382009,"option":"1, 2","correct":false},{"id":382010,"option":"2, 3","correct":false}]},{"q":"<p>You are assigned the task of improving the performance of the ‘Display result’ query involving two tables <strong>Student</strong> and <strong>Score</strong>. Both the tables have <em>roll_number</em> field as the primary key. After analyzing the query performance, you realize that the data in the student table is rarely updated, whereas the score table has maximum transactions. Therefore, you decide to create indexes on the respective tables.</p>\n\n<p>Now, which of the following combinations of SQL indexes on the table <strong>Student</strong> and the table <strong>Score </strong>can you use to maximize the query performance?<br>\n<br>\n </p>\n\n<ol>\n\t<li>Student table – clustered index on the roll_number field<br>\n\tScore table – nonclustered index on the roll_number field<br>\n\t<br>\n\t </li>\n\t<li>Student table – unique clustered index on the roll_number field<br>\n\tScore table – clustered index on the roll_number field<br>\n\t<br>\n\t </li>\n\t<li>Student table – unique clustered index on the roll_number field<br>\n\tScore table – nonclustered index on the roll_number field<br>\n\t<br>\n\t </li>\n\t<li>Student table – unique nonclustered index on roll_number field<br>\n\tScore table – nonclustered index on roll_number field<br>\n\t </li>\n</ol>","a":[{"id":383253,"option":"1","correct":false},{"id":383254,"option":"2","correct":false},{"id":383255,"option":"3","correct":true},{"id":383256,"option":"4","correct":false}]},{"q":"<p>In an SQL Server, which of the following syntaxes can you use to determine whether the tables contain external fragmentation?</p>","a":[{"id":382114,"option":"Avg_fragment_size_in_pages","correct":false},{"id":382115,"option":"Avg_page_space_used_in_percent","correct":false},{"id":382116,"option":"Avg_fragmentation_in_percent","correct":true},{"id":382117,"option":"Avg_record_size_in_bytes","correct":false}]},{"q":"<p>In SQL Server, which of the following methods can be used to preserve space on leaf pages and avoid splitting while creating indexes?</p>","a":[{"id":380988,"option":"Create clustered index","correct":false},{"id":380989,"option":"Create non-clustered index","correct":false},{"id":380990,"option":"Create index with FILLFACTOR","correct":true},{"id":380991,"option":"Create index using STATISTICS_NORECOMPUTE","correct":false}]},{"q":"<p>What is the output of the following C# code:</p>\n\n<p><strong>Code </strong></p>\n\n<pre class=\"prettyprint\"><code>using System;\t\nclass Hackerearth \n{   \n    string[] hack = new string[3];\t\n\tpublic string this[int h]\n\t{\n\t\tget\n\t\t{\n\t\t\tstring h1 = hack[h];\n\t\t\treturn h1;\n\t\t}\n\t\tset\n\t\t{\n\t\t\thack[h] = value;\n\t\t}\n\t}\n\t\n\tpublic string this[double h]\n\t{\n\t\tget\n\t\t{\t\n\t\t\treturn \" Hello \";\n\t\t}\n\t\t\n\t}\n\t\n\tpublic string this[string h]\n\t{\n\t\tget\n\t\t{\n\t\t\treturn \" Hi \";\n\t\t}\n\t}\n\t\n\tstatic void Main(string[] args)\n\t{\n\t    Hackerearth hack_object = new Hackerearth();\n\t    hack_object[2] = \" Hackerearth \";\n\t    Console.WriteLine(hack_object[2] + hack_object[\"Hackerearth\"] + hack_object[2.0]);\n\t    \n\t}\n}</code></pre>\n\n<p> </p>\n\n<p><strong>Output</strong></p>\n\n<ol>\n\t<li> \n\t<pre class=\"prettyprint\"><code>Hackerearth  Hi  Hello</code></pre>\n\t <br>\n\t </li>\n\t<li> \n\t<pre class=\"prettyprint\"><code>Hackerearth  Hi  Hackerearth</code></pre>\n\t<br>\n\t </li>\n\t<li> \n\t<pre class=\"prettyprint\"><code>Hello  Hi  Hello</code></pre>\n\t </li>\n</ol>","a":[{"id":1419442,"option":"2","correct":false},{"id":1419443,"option":"3","correct":false},{"id":1419444,"option":"1","correct":true},{"id":1419445,"option":"The code gives a compilation error","correct":false}]},{"q":"<p>In SQL, you are working on indexing. Now, if you are required to get the pointer of the root page of an index then which of the following system compatibility views can you use to perform this action?<br>\n </p>","a":[{"id":383225,"option":"Sysobjects","correct":false},{"id":383226,"option":"Sysreferences","correct":false},{"id":383227,"option":"Sysdepends","correct":false},{"id":383228,"option":"Sysindexes","correct":true}]},{"q":"<p>What is the output of the following C code:</p>\n<pre class=\"prettyprint\"><code>    #include &lt;stdio.h&gt;\n    int main(void)\n    {\n        char p;\n        char buff[10] = {1, 2, 3, 4, 5, 6, 9, 8};\n        p = (buff + 1)[5];\n        printf(\"%d\", p);\n    }\n</code></pre>","a":[{"id":125668,"option":"6","correct":false},{"id":125669,"option":"9","correct":true},{"id":125670,"option":"5","correct":false},{"id":125671,"option":"Compilation error","correct":false}]}]