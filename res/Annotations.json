[{"q":"<p>You working on a project using hibernate. You want to declare an embedded component and also override its column mapping. Which of the given options best describe the use of annotations for&nbsp;column mapping of an embedded object for a particular entity?</p>\n\n<p><strong>Options</strong></p>\n\n<p>1.</p>\n\n<pre class=\"prettyprint\"><code>@Entity\npublic class Hackereath implements Serializable{\n    @Embedded\n    @AttributeOverrides( {\n            @AttributeOverride(name=\"hack\", column = @Column(name=\"emphack\") ),\n            @AttributeOverride(name=\"name\", column = @Column(name=\"employeeid\") )\n    } )\n}          </code></pre>\n\n<p>2.</p>\n\n<pre class=\"prettyprint\"><code>@Entity\npublic class Hackereath implements Serializable{\n    @Embedded( {\n            @AttributeOverride(name=\"hack\", column = @Column(name=\"emphack\") ),\n            @AttributeOverride(name=\"name\", column = @Column(name=\"employeeid\") )\n    } )\n}          </code></pre>\n\n<p>3.</p>\n\n<pre class=\"prettyprint\"><code>@Entity\npublic class Hackereath implements Serializable{\n    @AttributeOverrides( {\n            @AttributeOverride(name=\"hack\", column = @Column(name=\"emphack\") ),\n            @AttributeOverride(name=\"name\", column = @Column(name=\"employeeid\") )\n    } )\n}          </code></pre>\n\n<p>4.</p>\n\n<pre class=\"prettyprint\"><code>@Entity\npublic class Hackereath implements Serializable{ \n   @AttributeOverride(name=\"hack\", column = @Column(name=\"emphack\") ),\n   @AttributeOverride(name=\"name\", column = @Column(name=\"employeeid\") )\n}          </code></pre>\n\n<p>&nbsp;</p>","a":[{"id":1740397,"option":"1","correct":true},{"id":1740398,"option":"2","correct":false},{"id":1740399,"option":"3","correct":false},{"id":1740400,"option":"4","correct":false}]},{"q":"<p>During development of a web-app using Spring Boot framework, Alice comes across the following code written by his colleague. Which of the following is true about this code?</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>@RestController \n@RequestMapping(\"/home\")\npublic class InCon \n{ \n   @RequestMapping(value = \"/fetch/{id}\", method = RequestMethod.GET) \n   String getDynamicUriValue(@PathVariable String id) \n   { \n      System.out.println(\"The ID is \" + id); \n      return \"The Dynamic URI parameter was fetched\"; \n   } \n   @RequestMapping(value = \"/fetch/{id:[a-z]+}/{name}\", method = RequestMethod.GET) \n   String getDynamicUriValueRegex(@PathVariable(\"name\") String name) \n   {\n      System.out.println(\"The Name is \" + name);\n      return \"Dynamic URI parameter fetched using regex\";\n   } \n}</code></pre>\n\n<p> </p>","a":[{"id":1655533,"option":"A request to /home will be handled by the default() method as the annotation does not specify any value.","correct":false},{"id":1655534,"option":"A request to /home will be handled by the @RequestMapping method as the annotation does not specify any value.","correct":false},{"id":1655535,"option":"A request to /home will be handled by the @RequestMapping method as the annotation does specify a specific value.","correct":false},{"id":1655536,"option":"The method getDynamicUriValue() will execute for a request to localhost:8080/home/fetch/10.","correct":true}]},{"q":"<p>While working on a Spring Boot application, you are required to use annotations to provide supplemental information about a program. Which of these statements is true about @Autowired annotation?</p>\n\n<p><strong>Statements</strong></p>\n\n<ol>\n\t<li>The @Autowired annotation can be used to autowire bean on the setter method.</li>\n\t<li>This annotation provides more fine-grained control over where and how autowiring should be accomplished.</li>\n\t<li>This annotation indicates that bean property is required while saving the bean data to database.</li>\n\t<li>This annotation indicates that bean property is required while serializing the bean.</li>\n</ol>","a":[{"id":1655529,"option":"1","correct":false},{"id":1655530,"option":"2","correct":true},{"id":1655531,"option":"3","correct":false},{"id":1655532,"option":"4","correct":false}]},{"q":"<p>You are using the @Retention annotation in Java to specify the way the marked annotations are stored. Which of the following if used will cause the marked annotation to be retained by the compiler during compilation and ignored by the JVM?</p>","a":[{"id":1655837,"option":"RetentionPolicy.SOURCE","correct":false},{"id":1655838,"option":"RetentionPolicy.CLASS","correct":true},{"id":1655839,"option":"RetentionPolicy.RUNTIME","correct":false},{"id":1655840,"option":"RetentionPolicy.TARGET","correct":false}]},{"q":"<p>Assume that you have applied the @SafeVarargs annotation on a Java method. In the given scenario, which of these warnings related to var args usage are suppressed?</p>","a":[{"id":1655833,"option":"Checked warnings","correct":false},{"id":1655834,"option":"Unchecked warnings","correct":true},{"id":1655835,"option":"Both checked and unchecked warnings","correct":false},{"id":1655836,"option":"Only warnings related to Input/Output","correct":false}]},{"q":"<p>In which of the following scenarios can you use annotations when working on a Java8 application?<br>\n1. With class instance creation expression<br>\n2. With type cast<br>\n3. With implements clause<br>\n4. With thrown exception declaration</p>","a":[{"id":1655825,"option":"Only 1 and 3","correct":false},{"id":1655826,"option":"Only 2 and 4","correct":false},{"id":1655827,"option":"Only 1, 3 and 4","correct":false},{"id":1655828,"option":"All 1, 2, 3 and 4","correct":true}]},{"q":"<p>Anita was working on Spring Boot annotations. She made a list of annotations.</p>\n\n<p><strong>Annotations</strong></p>\n\n<ol>\n\t<li><strong>@Controller</strong></li>\n\t<li><strong>@RequestMapping</strong></li>\n\t<li><strong>@Request</strong></li>\n</ol>\n\n<p> </p>\n\n<p>Anita gave these annotations to her friend and asked him to send the definitions of them. But Anita friend sent these as statements without mapping them to the required annotations.</p>\n\n<p><strong>Statements</strong></p>\n\n<p><strong>A.</strong> It maps HTTP request with a path to a controller method.<br>\n<strong>B.</strong> It marks the class as a web controller, capable of handling the requests.<br>\n<strong>C.</strong> This annotation does not exist</p>\n\n<p>Which of the following options map the annotations with the correct statements?</p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","a":[{"id":1580975,"option":"1 - A, 2 - B, 3 - C","correct":false},{"id":1580976,"option":"1 - B, 2 - A, 3 - C","correct":true},{"id":1580977,"option":"1 - A, 2 - C, 3 - B","correct":false},{"id":1580978,"option":"1 - B, 2 - C, 3 - A","correct":false}]},{"q":"<p>In Spring, you have developed a banking-based web application for which users need to sign-up their information to log in to the website. Now, you are working on the Spring MVC validation to&nbsp;restrict the input provided by the user. You are required to apply constraints on the object model by using various annotations. For this, you wanted to implement the Bean validation API. Now, which of the following statements about these annotations from this API are correct in this scenario:</p>\n\n<p><strong>Statements</strong></p>\n\n<ol>\n\t<li>The annotation&nbsp;<em>@NotNull</em><strong>&nbsp;</strong>determines that the value can't be null.</li>\n\t<li>The annotation&nbsp;<em>@Size</em><strong>&nbsp;</strong>determines that the size must be equal to the specified value.</li>\n\t<li>The annotation&nbsp;<em>@Max&nbsp;</em>determines that the number must be equal to or less than the specified value.</li>\n\t<li>The annotation&nbsp;<em>@RegExp&nbsp;</em>determines that the sequence follows the specified regular expression.</li>\n</ol>","a":[{"id":1763355,"option":"1, 2, and 3","correct":true},{"id":1763356,"option":"2, 3, and 4","correct":false},{"id":1763357,"option":"1, 3, and 4","correct":false},{"id":1763358,"option":"All of these","correct":false}]}]