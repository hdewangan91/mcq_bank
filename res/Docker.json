[{"q":"<p>You are working on a cloud native app in docker. You wish to run it in Azure. You have logged in to your Azure account. You need to create a docker context associated with ACI to deploy apps in API. Which of the following command syntax is used in creating a new context name?</p>","a":[{"id":1662849,"option":"docker context create name","correct":false},{"id":1662850,"option":"docker context aci create name","correct":false},{"id":1662851,"option":"docker aci context create name","correct":false},{"id":1662852,"option":"docker context create aci name","correct":true}]},{"q":"<p>Labels are a mechanism for applying metadata to docker objects. You are assigned the task of labeling objects in your applications. Which of these cannot be used in key-value pairs of labels?</p>","a":[{"id":1662845,"option":"com.example.*","correct":false},{"id":1662846,"option":"com.docker.*","correct":true},{"id":1662847,"option":"com.filename.*","correct":false},{"id":1662848,"option":"com.newfile.*","correct":false}]},{"q":"<p>You are working on an application in Docker. You want to increase the controllability of contents from dockerfile. You tried creating a copy file but even then you faced some limitations in gaining control. You have decided to change the base image. You proceed by creating a new base image named hello. Which of the following ways cannot be used to create the same?</p>\n\n<p><strong>Options</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>FROM scratch\nADD hello /\nCMD [\"/hello\"]</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>container# apt-get update &amp;&amp; apt-get install build-essential\ncontainer# cd /build\ncontainer# gcc -o hello -static -nostartfiles example.c\ndocker run --rm example</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>$ sudo debootstrap xenial xenial &gt; /dev/null\n$ sudo tar -C xenial -c . | docker import - xenial\n$ docker run xenial cat /etc/lsb-release\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04 LTS\"</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>docker build --tag hello</code></pre>\n\n<p><br>\n<br>\n </p>","a":[{"id":1662841,"option":"1","correct":false},{"id":1662842,"option":"2","correct":false},{"id":1662843,"option":"3","correct":false},{"id":1662844,"option":"4","correct":true}]},{"q":"<p>As a Docker developer, one has to switch between the developing environment and the production environment. You have used bind mounts on the developing side and stored the data by volume on the production side. You have also isolated Docker processes from host processes. What should you be doing on the production side, apart from the ones mentioned above, in order to ensure smooth processing?</p>\n\n<p><strong>Options</strong></p>\n\n<p><strong>1.</strong></p>\n\n<p>Running an NTP client on Docker host and in each container before syncing them all to the NTP server.</p>\n\n<p><strong>2.</strong></p>\n\n<p>Using secrets to store sensitive application data and configs for non-sensitive information.</p>\n\n<p><strong>3.</strong></p>\n\n<p>Using CI/CD pipeline to automatically build and test the environment.</p>\n\n<p><strong>4.</strong></p>\n\n<p>Using multi-stage build to enhance the versatility and robustness of the environment.</p>","a":[{"id":1662705,"option":"1","correct":true},{"id":1662706,"option":"2","correct":false},{"id":1662707,"option":"3","correct":false},{"id":1662708,"option":"4","correct":false}]},{"q":"<p>You are working on a storage driver API to model a key/value storage. There are several storage drivers as potential options. Which of the following would help you to resolve this?</p>\n\n<p><strong>Options</strong></p>\n\n<p><strong>1.</strong></p>\n\n<p>Use StorageDriverFactory interface to select a driver through parameter mapping</p>\n\n<p><strong>2.</strong></p>\n\n<p>Use factory, New to select correct instances for the driver</p>\n\n<p><strong>3.</strong></p>\n\n<p>Use selectSuite function to select the correct driver required through internal processing</p>\n\n<p><strong>4.</strong></p>\n\n<p>Use immemory and filesystem driver as they are generalized drivers that contain all other drivers in them.</p>","a":[{"id":1662701,"option":"1","correct":true},{"id":1662702,"option":"2","correct":false},{"id":1662703,"option":"3","correct":false},{"id":1662704,"option":"4","correct":false}]},{"q":"<p>Rebuilding images is great to ensure their security. You have chosen an image that is sufficiently small. You have also installed a package to increase the security of the chosen image. You have tagged the image and rebuilt it. While executing you find that the image did not get rebuilt successfully, which of the following options is likely the cause for the same?</p>","a":[{"id":1662697,"option":"Choosing larger images reduces rebuilding errors","correct":false},{"id":1662698,"option":"Unnecessary packages cause errors while rebuilding images","correct":true},{"id":1662699,"option":"Tagging is not a mandatory step and has to be done to the base image only","correct":false},{"id":1662700,"option":"Some data has to be stored in the container before rebuilding","correct":false}]},{"q":"<p>You are working on an app in Docker. You are determined to optimize Docker with CI/CD deployment. You have created an access token for DockerHub as the prerequisite step. Which of the following would be the first step in reducing build time and hence optimizing CI/CD operation?</p>","a":[{"id":1662693,"option":"Using Docker Hub Password","correct":false},{"id":1662694,"option":"Using build caches to reuse the layers","correct":true},{"id":1662695,"option":"Making the release images to go to Dockerhub exclusively","correct":false},{"id":1662696,"option":"Setting up functions to push PR images","correct":false}]},{"q":"<p>You are working on a delivery app on Docker. You are assigned the task of converting an application defined in compose file to AWS resource. Which of the following keys can be used with EC2 support for the same?</p>\n\n<p><strong>Options</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using service.deploy.update_config to select machine type</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using service.deploy.resources to select machine type and AMI</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using service.deploy.placement to select machine type and AMI</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using service.deploy.labels to select the labels regarding AMI</code></pre>\n\n<p> </p>","a":[{"id":1662689,"option":"1","correct":false},{"id":1662690,"option":"2","correct":false},{"id":1662691,"option":"3","correct":true},{"id":1662692,"option":"4","correct":false}]},{"q":"<p>B has just started developing apps using Docker. He/she has learned to persist the data but wants to provide additional data into the containers. Which of the following ways would help B to achieve this?</p>","a":[{"id":1662685,"option":"Using Mountpoints to mount source code","correct":false},{"id":1662686,"option":"Using Bindmounts to control the mountpoints","correct":true},{"id":1662687,"option":"Accessing Nodemount to control code variations","correct":false},{"id":1662688,"option":"Making use of Mountroot","correct":false}]},{"q":"<p>You are required to build multi-container applications. You need to select your CLI. Which among these would give you a better performance?</p>","a":[{"id":1662681,"option":"Using main docker CLI since it offers more versatility","correct":false},{"id":1662682,"option":"Using Daemon CLI as it gives persistent container management","correct":false},{"id":1662683,"option":"Using Compose CLI as it offers more functionality","correct":true},{"id":1662684,"option":"Using either Daemon CLI or Compose CLI","correct":false}]},{"q":"<p>You are working on an app on Docker. You have to create an environment variable to change the behavior of a process. Which of the flags can be used to set an environment variable from an external file?</p>\n\n<p><strong>Options</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using the key --e alongside docker run command</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using the key--env alongside docker var command</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using the key --env-file alongside docker run command</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>Using the key --env-ext alongside docker var command</code></pre>\n\n<p> </p>","a":[{"id":1662677,"option":"1","correct":false},{"id":1662678,"option":"2","correct":false},{"id":1662679,"option":"3","correct":true},{"id":1662680,"option":"4","correct":false}]},{"q":"<p>You are working on a new application in Docker using docker hub API. You need to create an authentication token. The screen showed a response code of 200. In which of the following scenarios will this response code be displayed?</p>","a":[{"id":1662673,"option":"When the authentication fails","correct":false},{"id":1662674,"option":"When the authentication is successful","correct":true},{"id":1662675,"option":"When there is a server error","correct":false},{"id":1662676,"option":"When the session has timed out","correct":false}]},{"q":"<p>uri is an ansible module that is used to send any kind of HTTP request. You are using ansible modules for interacting directly with rabbitmq but, you are not having ssh daemon in the docker container for Ansible to connect to. How would you use the rabbitmq docker container and explore the API?</p>","a":[{"id":1534488,"option":"docker run -d --name rabbitmq-mgmt1 --m json.tool rabbitmq:3.6-management-alpine","correct":false},{"id":1534489,"option":"rabbitmq-api-playbook.yml docker run","correct":false},{"id":1534490,"option":"docker run -d --name rabbitmq-mgmt1 -p 127.0.0.1:15672:15672 rabbitmq:3.6-management-alpine","correct":true},{"id":1534491,"option":"rabbitmq-api-playbook.yml docker run -p 127.0.0.1:15672:15672 rabbitmq:","correct":false}]},{"q":"<p>In Azure DevOps, you are working on the docker container.</p>\n\n<p>Which of the following properties will be enabled if you combine Azure DevOps and Azure integrations with the docker container:</p>\n\n<ol>\n\t<li>You can build custom docker images by using an Azure DevOps hosted Linux agent.</li>\n\t<li>You can push and store the docker images in a private repository.</li>\n\t<li>You can deploy and run the images inside the container.</li>\n</ol>","a":[{"id":1161895,"option":"1 and 2","correct":false},{"id":1161896,"option":"2 and 3","correct":false},{"id":1161897,"option":"1 and 3","correct":false},{"id":1161898,"option":"All of these","correct":true}]},{"q":"<p>Which of the following features of Docker makes it faster and lightweight when compared to other virtualization techniques?</p>","a":[{"id":655336,"option":"Container runs on physical hardware via an inter-mediation layer","correct":false},{"id":655337,"option":"Container runs the userspace on top of the operating system’s kernel","correct":true},{"id":655338,"option":"Container consists of applications, guest operating systems, and necessary binaries and libraries","correct":false},{"id":655339,"option":"All of these","correct":false}]},{"q":"<p>In Docker, which of the following operations is provided by the Docker cloud:</p>\n\n<ol>\n\t<li>Node</li>\n\t<li>Application integration</li>\n\t<li>Continuous deployment</li>\n</ol>","a":[{"id":570678,"option":"1 and 2","correct":true},{"id":570679,"option":"3 and 4","correct":false},{"id":570680,"option":"All of these","correct":false},{"id":570681,"option":"None of these","correct":false}]},{"q":"<p>Which of the following keywords are used in a Docker program?</p>","a":[{"id":570534,"option":"Develop, code, and ship","correct":false},{"id":570535,"option":"Analyze, ship, and migrate","correct":false},{"id":570536,"option":"Develop, code, and migrate","correct":false},{"id":570537,"option":"Develop, ship, and run","correct":true}]},{"q":"<p>Which of the following is a component of the Docker program?</p>","a":[{"id":570558,"option":"Docker - Overview","correct":true},{"id":570559,"option":"Docker for engine","correct":false},{"id":570560,"option":"Docker for containers","correct":false},{"id":570561,"option":"Docker for VM","correct":false}]},{"q":"<p>Which of the following Docker CLI commands is used to find Docker image layers and its size? </p>","a":[{"id":655816,"option":"docker history  \"Image_Id\"","correct":true},{"id":655817,"option":"docker layers  \"Image_Id\"","correct":false},{"id":655818,"option":"docker image -layers  \"Image_Id\"","correct":false},{"id":655819,"option":"docker image layers  \"Image_Id\"","correct":false}]},{"q":"<p>In Docker, which of the following syntaxes is used to delete a container?</p>","a":[{"id":570670,"option":"docker stop ContainerID ","correct":false},{"id":570671,"option":"docker stats ContainerID ","correct":false},{"id":570672,"option":"docker rm ContainerID","correct":true},{"id":570673,"option":"All of these","correct":false}]},{"q":"<p>You are working with CI/CD pipelines. You are creating a Continuous Integration (CI) commit pipeline using Docker. If you are required to download the source code from the repository, then which of the following levels of this commit pipeline is implemented to perform this action in this scenario?</p>","a":[{"id":658108,"option":"Checkin level","correct":false},{"id":658109,"option":"Checkout level","correct":true},{"id":658110,"option":"Compile level","correct":false},{"id":658111,"option":"Unit test level","correct":false}]},{"q":"<p>Which of the following Docker commands are used to perform the following tasks:</p>\n\n<p><strong>Tasks</strong></p>\n\n<ol>\n\t<li>Remove one or more images</li>\n\t<li>Remove one or more containers</li>\n\t<li>List out all the images with their repositories and sizes</li>\n</ol>\n\n<p><strong>Commands</strong></p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>1. docker image rmie\n2. docker rm\n3. docker image images</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>1. docker image rmi\n2. docker image rm\n3. docker images</code></pre>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>1. docker image rm\n2. docker rm\n3. docker images</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>1. docker image rm\n2. docker rm\n3. docker image images</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":570662,"option":"1","correct":false},{"id":570663,"option":"2","correct":false},{"id":570664,"option":"3","correct":true},{"id":570665,"option":"4","correct":false}]},{"q":"<p>In Docker, which of the following execution result sequences is correct?</p>","a":[{"id":655851,"option":"Docker Image -> Dockerfile -> Docker Container","correct":false},{"id":655852,"option":"Docker Image  -> Docker Container -> Dockerfile","correct":false},{"id":655853,"option":"Dockerfile -> Docker Container -> Docker Image   ","correct":false},{"id":655854,"option":"Dockerfile -> Docker Image -> Docker Container","correct":true}]},{"q":"<p>Which of the following statements about the Docker program is correct:</p>\n\n<ol>\n\t<li>It has the ability to reduce the size of development by providing a smaller footprint of the operating system via containers</li>\n\t<li>Its containers can be deployed on physical machines, virtual machines, and the cloud.</li>\n\t<li>Its containers are lightweight in nature, and therefore, are easily scalable.</li>\n</ol>","a":[{"id":570554,"option":"1 and 2","correct":false},{"id":570555,"option":"1 and 3","correct":false},{"id":570556,"option":"All of these","correct":true},{"id":570557,"option":"None of these","correct":false}]}]