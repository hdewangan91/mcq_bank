[{"q":"<p>A Mutating Trigger Error is encountered if a procedure that updates a column of table X is called in a database trigger of the same table. What can you do to avoid this error?</p>","a":[{"id":1616851,"option":"Procedure should be declared as an AUTONOMOUS TRANSACTION","correct":false},{"id":1616852,"option":"You need to have a row level as well as a statement level trigger","correct":false},{"id":1616853,"option":"You need to declare only a statement level trigger","correct":false},{"id":1616854,"option":"Both 1 and 2","correct":true}]},{"q":"<p>In SQL, you are working on DML triggers, and you have created nested triggers, now up to how many levels can DML triggers be nested? </p>","a":[{"id":383301,"option":"32","correct":true},{"id":383302,"option":"10","correct":false},{"id":383303,"option":"7","correct":false},{"id":383304,"option":"20","correct":false}]},{"q":"<p>In Azure functions, you are working on triggers and binding definitions. Determine the direction value of a trigger that you are required to include in the JSON file of your function.</p>","a":[{"id":1340971,"option":"in","correct":true},{"id":1340972,"option":"out","correct":false},{"id":1340973,"option":"inout","correct":false},{"id":1340974,"option":"It depends on the input and the output bindings.","correct":false}]},{"q":"<p>Based on the following code, what is the output of the PL/SQL query:</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>CREATE OR REPLACE FUNCTION welcome_hck(p_name IN VARCHAR2)\nRETURN VARCHAR2\nIS\nBEGIN\nRETURN('Welcome'||p_name);\nEND;\n\nDECLARE\nlv_msg VARCHAR2(250);\nBEGIN\nlv_msg:=welcome_hck('HackerEarth');\ndbms_output.put_line(lv_msg);\nEND;</code></pre>\n\n<p><strong>Query</strong></p>\n\n<pre class=\"prettyprint\"><code>SELECT welcome_hck('HackerEarth') FROM DUAL;</code></pre>\n\n<p> </p>","a":[{"id":818149,"option":"HackerEarth","correct":false},{"id":818150,"option":"Welcome HackerEarth","correct":true},{"id":818151,"option":"Welcome","correct":false},{"id":818152,"option":"Returns an error","correct":false}]},{"q":"<p>In PL/SQL, you are working on the correlation names and the pseudo records in the triggers. Which of the following statements about the restrictions on the pseudo records are correct:<br>\n1. A pseudo record always must be contained in a record-level operation.<br>\n2. A pseudo record cannot be an actual subprogram parameter.<br>\n3. If the triggering statement is DELETE, then the trigger cannot change NEW field values.<br>\n4. An AFTER trigger cannot change NEW field values, because the triggering statement runs before the trigger fires.</p>","a":[{"id":1139959,"option":"1, 2, and 3","correct":false},{"id":1139960,"option":"2, 3, and 4","correct":true},{"id":1139961,"option":"1, 2, and 4","correct":false},{"id":1139962,"option":"1, 3, and 4","correct":false}]},{"q":"<p>In Azure, if you have a trigger in the data, then the trigger will enforce data integrity in the target ahead of the replicated data from the source. Which of the following SQL queries must be executed to disable triggers in the target database?</p>","a":[{"id":1152697,"option":"SELECT SchemaName, GROUP_CONCAT(DropQuery SEPARATOR ';\\n') as DropQuery, GROUP_CONCAT(AddQuery SEPARATOR ';\\n') as AddQuery","correct":false},{"id":1152698,"option":"SELECT SchemaName as DropQuery Group_CONCAT(AddQuery SEPARATOR ‘;\\n’) as AddQuery","correct":false},{"id":1152699,"option":"SELECT Concat(‘DROP TRIGGER’, Trigger_Name, ‘;’) FROM information_schema.TRIGGERS WHERE TRIGGER_SCHEMA = ‘your_schema’;","correct":true},{"id":1152700,"option":"SELECT Concat(Trigger_Name, ‘;’) FROM information_schema.TRIGGERS WHERE TRIGGER_SCHEMA=’your_schema’;","correct":false}]},{"q":"<p>In PL/SQL, you are working on the triggers. Which of the following statements about the Compound DML trigger are correct:<br>\n1. It is created on a non-editioning view that is not really compound.<br>\n2. It can be conditional and autonomous.<br>\n3. It is used to accumulate rows destined for a second table so that you can periodically bulk-insert the rows.<br>\n4. It is used to avoid mutating-table error (ORA-04091).</p>","a":[{"id":1139947,"option":"1, 2, and 3","correct":false},{"id":1139948,"option":"2, 3, and 4","correct":false},{"id":1139949,"option":"1, 2, and 4","correct":false},{"id":1139950,"option":"1, 3, and 4","correct":true}]},{"q":"<p>In PL/SQL, you are working on the triggers. Which of the following statements about the INSTEAD OF DML triggers are correct:<br>\n1. It is a DML trigger created on a non-editioning view.<br>\n2. An INSTEAD OF trigger is the only way to update a view that is inherently updatable.<br>\n3. An INSTEAD OF trigger can read OLD and NEW values, but cannot change them.<br>\n4. An INSTEAD OF trigger with the NESTED TABLE clause fires only if the triggering statement operates on the elements of the specified nested table column of the view.</p>","a":[{"id":1139943,"option":"1, 2, and 3","correct":false},{"id":1139944,"option":"2, 3, and 4","correct":false},{"id":1139945,"option":"1, 2, and 4","correct":false},{"id":1139946,"option":"1, 3, and 4","correct":true}]},{"q":"<p>In PL/SQL, you are working on the triggers. If two or more triggers with different timing points are defined for the same statement on the same table, then which of the following sequences of steps about the order in which trigger fires is correct:<br>\n1. All BEFORE STATEMENT triggers<br>\n2. All AFTER STATEMENT triggers<br>\n3. All BEFORE EACH ROW triggers<br>\n4. All AFTER EACH ROW triggers</p>","a":[{"id":1139967,"option":"1 -> 2 -> 3 -> 4","correct":false},{"id":1139968,"option":"3 -> 4 -> 1 -> 2","correct":false},{"id":1139969,"option":"1 -> 3 -> 2 -> 4","correct":false},{"id":1139970,"option":"1 -> 3 -> 4 -> 2","correct":true}]},{"q":"<p>In PL/SQL, you are working on the triggers. Which of the following statements about the Compound DML trigger restrictions are correct:<br>\n1. Only the BEFORE EACH ROW section can change the value of the PARENT statement.<br>\n2. A timing-point section cannot handle exceptions raised in another timing-point section.<br>\n3. If a timing-point section includes a GOTO statement, then the target of the GOTO statement must be in the same timing-point section.</p>","a":[{"id":1139951,"option":"1 and 2","correct":false},{"id":1139952,"option":"2 and 3","correct":true},{"id":1139953,"option":"1 and 3","correct":false},{"id":1139954,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the exception handling in the triggers. Which of the following scenarios have the database rolls back only the effects of the trigger, but not the effects of the triggering statement:<br>\n1. The triggering event is either AFTER STARTUP ON DATABASE or BEFORE SHUTDOWN ON DATABASE.<br>\n2. The triggering event is AFTER LOGON ON DATABASE and the user has the SUPER DATABASE TRIGGER privilege.<br>\n3. The triggering event is AFTER LOGON ON SCHEMA and the user either owns the schema or has the ALTER ANY TRIGGER privilege.</p>","a":[{"id":1139963,"option":"1 and 2","correct":false},{"id":1139964,"option":"2 and 3","correct":false},{"id":1139965,"option":"1 and 3","correct":true},{"id":1139966,"option":"All of these","correct":false}]},{"q":"<p>n PL/SQL, triggers are only used to enforce complex security authorizations that you cannot define using the database security features provided with the database. If a trigger is used to enforce a complex security authorization, it is preferred to use a BEFORE statement trigger. Which of the following statements represents the advantages of using the BEFORE statement trigger in this scenario:<br>\n1. The security check is done before the triggering statement is allowed to run such that no wasted work is done by an unauthorized statement.<br>\n2. The security check is done only for the triggering statement of each row that is affected by the triggering statement.</p>","a":[{"id":1139955,"option":"1","correct":true},{"id":1139956,"option":"2","correct":false},{"id":1139957,"option":"Both of these","correct":false},{"id":1139958,"option":"None of these","correct":false}]}]