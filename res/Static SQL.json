[{"q":"<p>In PL/SQL, which of the following statements ends the current transaction and undoes any changes made during that transaction?</p>","a":[{"id":1139855,"option":"CONTINUE","correct":false},{"id":1139856,"option":"ROLLBACK","correct":true},{"id":1139857,"option":"TERMINATE","correct":false},{"id":1139858,"option":"KILL","correct":false}]},{"q":"<p>In PL/SQL, you are working on the static SQL statements. Which of the following represents the Data Manipulation Language(DML) statements:<br>\n1. INSERT<br>\n2. UPDATE<br>\n3. DELETE<br>\n4. MERGE</p>","a":[{"id":1139727,"option":"1, 2, and 3","correct":false},{"id":1139728,"option":"2, 3, and 4","correct":false},{"id":1139729,"option":"1, 3, and 4","correct":false},{"id":1139730,"option":"All of these","correct":true}]},{"q":"<p>In PL/SQL, you are processing the query result sets. If you are required to use the SELECT statement only in the cursor FOR LOOP statement, which of the following actions must be performed?</p>","a":[{"id":1139819,"option":"Specify the SELECT statement inside the cursor FOR LOOP statement.","correct":true},{"id":1139820,"option":"Specify the SELECT statement outside the cursor FOR LOOP statement.","correct":false},{"id":1139821,"option":"Both of these","correct":false},{"id":1139822,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on static SQL statements. You have created a table sequence. After a sequence is created, you can access its values in SQL statements with the NEXTVAL pseudo column, which increments the sequence and returns the new value. You are referencing the sequence_name.NEXTVAL to increment the sequence. You have tried to roll back the transaction and you found it failed. Which of the following statements are responsible for this failure of rollback?</p>","a":[{"id":1139743,"option":"Each time you reference sequence_name.NEXTVAL, the sequence is incremented immediately.","correct":false},{"id":1139744,"option":"Each time you reference sequence_name.NEXTVAL, the sequence is incremented immediately and permanently.","correct":true},{"id":1139745,"option":"Both of these","correct":false},{"id":1139746,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If an explicit cursor is not open, then which of the following predefined exception is raised by the explicit cursor attribute %ROWCOUNT?</p>","a":[{"id":1139803,"option":"NOT_OPEN_ERROR","correct":false},{"id":1139804,"option":"NOT_OPEN","correct":false},{"id":1139805,"option":"UNKNOWN_CURSOR","correct":false},{"id":1139806,"option":"INVALID_CURSOR","correct":true}]},{"q":"<p>In PL/SQL, which of the following statements ends the current transaction by making the permanent changes and visible to other users?</p>","a":[{"id":1139851,"option":"COMMIT","correct":true},{"id":1139852,"option":"TRUNCATE","correct":false},{"id":1139853,"option":"EXIT","correct":false},{"id":1139854,"option":"ABORT","correct":false}]},{"q":"<p>In PL/SQL, you are declaring the cursor variable as a formal parameter of a subprogram. If the subprogram only fetches from the cursor variable, which of the following can be the parameter modes:<br>\n1. IN<br>\n2. OUT<br>\n3. IN OUT</p>","a":[{"id":1139843,"option":"Either 1 or 2","correct":false},{"id":1139844,"option":"Either 2 or 3","correct":false},{"id":1139845,"option":"Either 1 or 3","correct":true},{"id":1139846,"option":"Only 2","correct":false}]},{"q":"<p>In PL/SQL, you are processing the query result by handling the large multiple-row result sets. If you are required to assign the large quantity of the table data to the variables, then which of the following clauses must be used along with the SELECT INTO statement?</p>","a":[{"id":1139815,"option":"BULK COLLECT","correct":true},{"id":1139816,"option":"BULK STORE","correct":false},{"id":1139817,"option":"BULK DATA","correct":false},{"id":1139818,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to create a cursor variable, then which of the following types must be defined?</p>","a":[{"id":1139827,"option":"SYS_REFCURSOR type","correct":false},{"id":1139828,"option":"REF CURSOR type and defined variable with the cursor type.","correct":false},{"id":1139829,"option":"Either 1 or 2","correct":true},{"id":1139830,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following attributes of the implicit cursor are correct:<br>\n1. SQL%ISOPEN<br>\n2. SQL%ISCLOSE<br>\n3. SQL%FOUND<br>\n4. SQL%NOTFOUND</p>","a":[{"id":1139767,"option":"1, 2, and 3","correct":false},{"id":1139768,"option":"2, 3, and 4","correct":false},{"id":1139769,"option":"1, 2, and 4","correct":false},{"id":1139770,"option":"1, 3, and 4","correct":true}]},{"q":"<p>In PL/SQL, which of the following syntaxes about the REF CURSOR type definition is correct?</p>","a":[{"id":1139831,"option":"TYPE type_name IS REF CURSOR [ RETURN return_type ]","correct":true},{"id":1139832,"option":"TYPE type_name IS REF CURSOR { RETURN return_type }","correct":false},{"id":1139833,"option":"TYPE type_name AS REF CURSOR [ RETURN return_type ]","correct":false},{"id":1139834,"option":"TYPE type_name AS REF CURSOR { RETURN return_type }","correct":false}]},{"q":"<p>In PL/SQL which of the following statements about the advantages of implementing the autonomous transaction are correct:<br>\n1. It shares locks, resources, and the commit-dependencies with the main transaction.<br>\n2. It is used to increment the retry counters even if the main transaction rolls back.<br>\n3. It can be encapsulated in the stored subprograms.</p>","a":[{"id":1139875,"option":"1 and 2","correct":false},{"id":1139876,"option":"2 and 3","correct":true},{"id":1139877,"option":"1 and 3","correct":false},{"id":1139878,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to fetch the rows of the query result set after opening an explicit cursor, then which of the following syntax is used to perform this action?</p>","a":[{"id":1139795,"option":"FETCH cursor_name","correct":false},{"id":1139796,"option":"FETCH cursor_name AS into_clause","correct":false},{"id":1139797,"option":"FETCH cursor_name LIKE into_clause","correct":false},{"id":1139798,"option":"FETCH cursor_name INTO into_clause","correct":true}]},{"q":"<p>In PL/SQL, you are working on the static SQL statements. Which of the following SQL pseudo columns are included in the static SQL:<br>\n1. CURRVAL<br>\n2. LEVEL<br>\n3. OBJECT_VALUE</p>","a":[{"id":1139739,"option":"1 and 2","correct":false},{"id":1139740,"option":"2 and 3","correct":false},{"id":1139741,"option":"1 and 3","correct":false},{"id":1139742,"option":"All of these","correct":true}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to determine the number of rows affected by the FORALL statement, then which of the following implicit cursor attributes is used to perform this action?</p>","a":[{"id":1139771,"option":"SQL%BULK_ROWCOUNT","correct":true},{"id":1139772,"option":"SQL%ROWCOUNT","correct":false},{"id":1139773,"option":"SQL%BULK_EXCEPTION","correct":false},{"id":1139774,"option":"SQL%BULK_ROW","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to determine the number of cursors that a session can have open simultaneously, then which of the following factors are required to perform this action:<br>\n1. The number of cursors that are used in a rollback transaction.<br>\n2. Amount of memory available for a session.<br>\n3. The value of the initialization parameter OPEN_CURSORS</p>","a":[{"id":1139759,"option":"1 and 2","correct":false},{"id":1139760,"option":"2 and 3","correct":true},{"id":1139761,"option":"1 and 3","correct":false},{"id":1139762,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following cursors is constructed and maintained by the PL/SQL?</p>","a":[{"id":1139751,"option":"Implicit cursor","correct":true},{"id":1139752,"option":"Explicit cursor","correct":false},{"id":1139753,"option":"Both of these","correct":false},{"id":1139754,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to process the query result sets by using the cursors, then which of the following PL/SQL statements uses the explicit cursor:<br>\n1. OPEN<br>\n2. SELECT INTO<br>\n3. FOR LOOP<br>\n4. FETCH</p>","a":[{"id":1139811,"option":"1 and 2","correct":false},{"id":1139812,"option":"3 and 4","correct":false},{"id":1139813,"option":"2 and 3","correct":false},{"id":1139814,"option":"1 and 4","correct":true}]},{"q":"<p>In PL/SQL, you are working with autonomous transactions. If you try to exit an active autonomous transaction without committing or rolling back, the database raises an exception. Which of the following statements in this scenario is correct?</p>","a":[{"id":1139887,"option":"If the exception is unhandled, then the transaction rolls back.","correct":true},{"id":1139888,"option":"If the exception is unhandled, then the transaction preserves its state by throwing the SAVEPOINT statement.","correct":false},{"id":1139889,"option":"If the exception is unhandled, then the transaction is lead to a deadlock.","correct":false},{"id":1139890,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If an explicit cursor query includes a virtual column, then which of the following conditions must be true such that the column must have an alias feature:<br>\n1. The cursor is used to fetch into a record that was declared with %ROWTYPE.<br>\n2. The cursor is used to store the session record that was invoked with %ROW_SIZE.</p>","a":[{"id":1139799,"option":"1","correct":true},{"id":1139800,"option":"2","correct":false},{"id":1139801,"option":"Both of these","correct":false},{"id":1139802,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following statements about the explicit cursor are correct:<br>\n1. This cursor is defined and declared by giving it a name and associating it with a query.<br>\n2. This cursor is used in a cursor FOR LOOP statement to process the query result set.<br>\n3. A value cannot be assigned to this cursor by using the value as in expression.</p>","a":[{"id":1139787,"option":"1 and 2","correct":true},{"id":1139788,"option":"2 and 3","correct":false},{"id":1139789,"option":"1 and 3","correct":false},{"id":1139790,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, which of the following statements about the autonomous transactions are correct:<br>\n1. This is an independent transaction started by the main transaction.<br>\n2. The autonomous routine commits a minimum of three autonomous transactions namely AT1, AT2, and AT3.<br>\n3. It performs the SQL operations and commit or rollback, without committing or rolling back the main transaction.</p>","a":[{"id":1139871,"option":"1 and 2","correct":false},{"id":1139872,"option":"2 and 3","correct":false},{"id":1139873,"option":"1 and 3","correct":true},{"id":1139874,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, which of the following statements are allowed in the read-only transaction:<br>\n1. FETCH<br>\n2. DROP<br>\n3. OPEN<br>\n4. LOCK TABLE</p>","a":[{"id":1139867,"option":"1, 2, and 3","correct":true},{"id":1139868,"option":"2, 3, and 4","correct":false},{"id":1139869,"option":"1, 2, and 4","correct":false},{"id":1139870,"option":"1, 3, and 4","correct":false}]},{"q":"<p>In PL/SQL, you are working on working on the cursors. Which of the following statements about the implicit cursor are correct:<br>\n1. PL/SQL opens an implicit cursor every time you run a SELECT or DML statement.<br>\n2. SQLattribute always refers to the least recently run SELECT or DML statement.<br>\n3. If no DML is executed, then the value of the SQLattribute is NULL</p>","a":[{"id":1139763,"option":"1 and 2","correct":false},{"id":1139764,"option":"2 and 3","correct":false},{"id":1139765,"option":"1 and 3","correct":true},{"id":1139766,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the collections. If you are required to query a collection, then which of the following conditions must be satisfied:<br>\n1. The data type of the collection was either created at a schema level or declared in a package specification.<br>\n2. The data type of the collection element is either a dynamic data type, a user-defined type, or a record type.</p>","a":[{"id":1139839,"option":"1","correct":true},{"id":1139840,"option":"2","correct":false},{"id":1139841,"option":"Both of these","correct":false},{"id":1139842,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursor variables. If you have assigned a value of the cursor variable VAR1 to another cursor variable VAR2, then which of the following statements in this scenario is correct:<br>\n1. If VAR1 is not open, then after the assignment, VAR2 is still open.<br>\n2. If VAR1 is open, opening VAR2 after the assignment does not open VAR1.</p>","a":[{"id":1139835,"option":"1","correct":false},{"id":1139836,"option":"2","correct":false},{"id":1139837,"option":"Both of these","correct":false},{"id":1139838,"option":"None of these","correct":true}]},{"q":"<p>In PL/SQL, you are processing the query result sets with the subqueries. If you are required to process a query result set by looping through the query and running another query for each row, then which of the following actions must be implemented to improve the query performance:<br>\n1. Remove the second query from inside the FOR loop.<br>\n2. Include the first query to the FETCH statement.<br>\n3. Make the second query as the subquery for the firsts query.</p>","a":[{"id":1139823,"option":"1 and 2","correct":false},{"id":1139824,"option":"2 and 3","correct":false},{"id":1139825,"option":"1 and 3","correct":true},{"id":1139826,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, which of the following statements about the transaction context in the autonomous transactions are correct:<br>\n1. When one autonomous routine invokes another routine, the routines share the transaction context.<br>\n2. When an autonomous routine invokes a nonautonomous routine, the routines receive the same transaction context.</p>","a":[{"id":1139879,"option":"1","correct":true},{"id":1139880,"option":"2","correct":false},{"id":1139881,"option":"Both of these","correct":false},{"id":1139882,"option":"None of these","correct":false}]},{"q":"<p>vIn PL/SQL, which of the following transactions are used to run multiple queries while other users update the same tables?</p>","a":[{"id":1139859,"option":"Read-only transactions","correct":true},{"id":1139860,"option":"Write-only transactions","correct":false},{"id":1139861,"option":"Read-Write transactions","correct":false},{"id":1139862,"option":"None of these","correct":false}]}]