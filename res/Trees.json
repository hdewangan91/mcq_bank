[{"q":"<p>Alice and Bob were discussing their family trees and were confused about whether their family tree was perfect or not. They later realized that for a family tree to be perfect all internal nodes should have two children and all leaves are at the same level.</p>\n\n<p>Can you help Alice and Bob in checking the conditions of the family tree required to implement the given pseudocode in the most efficient way possible?</p>\n\n<pre class=\"prettyprint\"><code>bool familytree(struct Node* ref, int d, int level = 0)\n    if (ref == NULL)\n        return true\n    if (ref-&gt;left == NULL &amp;&amp; ref-&gt;right == NULL)\n        return (d == level+1)\n    if (ref-&gt;left == NULL || ref-&gt;right == NULL)\n        return false\n    return familytree(root-&gt;left, d, level+1) &amp;&amp;\n           familytree(root-&gt;right, d, level+1)</code></pre>\n\n<p>What will be the time complexity of the given code?</p>","a":[{"id":1654722,"option":"O(N)","correct":true},{"id":1654723,"option":"O(logN)","correct":false},{"id":1654724,"option":"O(NlogN","correct":false},{"id":1654725,"option":"O(N^2)","correct":false}]},{"q":"<p>Alice and her friends were playing a game. They were given a binary search tree with K nodes and a starting root of the tree. Alice was asked to figure out a way to find the Mth smallest element present. While writing the code some of the lines went missing.</p>\n\n<pre class=\"prettyprint\"><code>int findele(Node *ref, int M)\n  int c = 0\n  int Ms = INT_MIN\n  Node *curr = root\n  while (curr != NULL)\n   if (curr-&gt;left == NULL)\n     c++;\n     if (c==M)\n       Ms = curr-&gt;key\n     curr = curr-&gt;right\n    else\n      Node *last = curr-&gt;left\n      while (last-&gt;right != NULL &amp;&amp; last-&gt;right != curr)\n        last= last-&gt;right\n      if (last-&gt;right==NULL)\n        //LINE 6\n        //LINE 7\n      else\n       last-&gt;right = NULL\n       c++;\n       if (c==k)\n         Ms = curr-&gt;key\n       curr = curr-&gt;right\n    return Ms\n </code></pre>\n\n<p>Can you help Alice and her friends in finding the code for line 6 and line 7?</p>\n\n<p><strong>Options</strong></p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>last-&gt;right = curr;\ncurr = curr-&gt;left;</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>last-&gt;left = curr;\ncurr = curr-&gt;left;</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>last-&gt;right = curr;\ncurr = curr-&gt;right;</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>last-&gt;left = curr-&gt;right;\ncurr-&gt;right = curr-&gt;left;</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":1654177,"option":"1","correct":true},{"id":1654178,"option":"2","correct":false},{"id":1654179,"option":"3","correct":false},{"id":1654180,"option":"4","correct":false}]},{"q":"<p>Alice loves to take on challenges especially when they are of data structures and algorithms. This time she was given a preorder traversal of the binary search tree and was asked to find all the external nodes of it. Alice was excited but at the same time scared also as she was supposed to do the task in the most efficient way possible.</p>\n\n<p>Alice did come up with a pseudocode but was unaware of its efficiency.</p>\n\n<p><strong>Pseudocode</strong></p>\n\n<pre class=\"prettyprint\"><code>int Search(int in[], int l, int r, int d)\n{\n    int m = (l + r)&gt;&gt;1;\n    if (in[m] == d)\n        return m;\n    else if (in[m] &gt; d)\n        return Search(in,l,m-1,d);\n    else\n        return Search(in,m+1,r,d);\n}\nvoid external(int pre[], int in[],\n                  int l, int r, int *ind, int n)\n{\n    if(l == r)\n    {\n        printf(\"%d \", in[l]);\n        *ind = *ind + 1;\n        return;\n    }\n    if (l &lt; 0 || l &gt; r || r &gt;= n)\n        return;\n    int loc = Search(in, l, r, pre[*ind]);\n    *ind = *ind + 1;\n \n    external(pre, in, l, loc - 1, ind, n);\n    external(pre, in, loc + 1, r, ind, n);\n}\n void leafNodes(int pre[], int n)\n{\n    int in[n];  \n        for (int i = 0; i &lt; n; i++)\n        in[i] = pre[i];\n    sort(in, in + n);\n    int ind = 0;\n    external(pre, in, 0, n - 1, &amp;ind, n);\n}</code></pre>\n\n<p>What will be the time complexity?</p>","a":[{"id":1653229,"option":"O(n)","correct":false},{"id":1653230,"option":"O(nlogn)","correct":true},{"id":1653231,"option":"O(logn)","correct":false},{"id":1653232,"option":"O(n^2)","correct":false}]},{"q":"<p>Alice was telling Bob about their ancestors. Bob was very curious to know if he could implement the same concept on trees. He proposed Alice to play a game with him.</p>\n\n<p>The rules of the game were pretty simple. Bob will give Alice a Node and will be asked to tell its <em>N<sup>th</sup></em> ancestor. Alice came up with a code to solve the challenge but was unable to complete it.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>Node* game(Node *ref, int node , int &amp;N)\n{  \n    if (!ref)\n        return NULL;\n    if (/*line 6*/ ||(temp =  game(ref-&gt;left,node,N)) ||\n               (temp =  game(ref-&gt;right,node,N)))\n    {  \n        if (N &gt; 0)       \n            N--;\n        else if (N == 0)\n        {\n            cout&lt;&lt;ref-&gt;data;\n            return NULL;\n        }\n        return ref;\n    }\n}</code></pre>\n\n<p>What will come in place of line 6?</p>\n\n<p><strong>Options</strong></p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>ref-&gt;data == node</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>ref-&gt;left-&gt;data==node</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>ref-&gt;right-&gt;data==node</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>None of these</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":1652461,"option":"1","correct":true},{"id":1652462,"option":"2","correct":false},{"id":1652463,"option":"3","correct":false},{"id":1652464,"option":"4","correct":false}]},{"q":"<p>Alice was given a task and was asked to do it in the best way possible. She had to remove all the keys from the Binary Search Tree (with N number of nodes) which are not in a given range. </p>\n\n<p>For example,</p>\n\n<p><strong>Input:</strong> Given BST with 7 nodes and the range [60, 80]</p>\n\n<pre>            50\n          /     \\\n         30      70\n        /  \\    /  \\\n      20   40  60   80 </pre>\n\n<p><strong>Ouput</strong></p>\n\n<pre>           50\n          /\n         30\n        /  \\\n      20   40\n</pre>\n\n<p>The task seemed easy to him but wasn't sure about the efficiency of the solution. Will you help him find out the complexity?</p>\n\n<pre class=\"prettyprint\"><code>tree* remrange(tree *ref, int mini, int maxi){\n if (ref == NULL)\n   return NULL;\n ref-&gt;left =  remrange(ref-&gt;left, mini, maxi)\n ref-&gt;right =  remrange(ref-&gt;right, mini, maxi)\n if (ref-&gt;key &lt; mini)\n  tree *m = ref-&gt;right\n  delete ref\n  return m\n if (ref-&gt;key &gt; maxi)\n  tree *n = ref-&gt;left\n  delete ref\n  return n\n return ref</code></pre>\n\n<p> </p>","a":[{"id":1651585,"option":"O(N^2)","correct":false},{"id":1651586,"option":"O(N)","correct":true},{"id":1651587,"option":"O(logN)","correct":false},{"id":1651588,"option":"O(NlogN)","correct":false}]},{"q":"<p>Alice and Bob were working on trees. While going through it they had the idea that it might be possible that some of their nodes could be identical and hence started thinking about what would be the most efficient way of making that happen.</p>\n\n<p>They came up with a code for two trees having M and N number of nodes respectively.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>void find_identical(Node *r1, Node *r2)\n{\n    stack&lt;Node *&gt; stack1, s1, s2;\n    while (true)\n    {\n        if (r1)\n        {\n            s1.push(root1);\n            r1 = r1-&gt;left;\n        }\n        else if (r2)\n        {\n            s2.push(r2);\n            r2 = r2-&gt;left;\n        }\n        else if (!s1.empty() &amp;&amp; !s2.empty())\n        {\n            r1 = s1.top();\n            r2 = s2.top();\n            if (r1-&gt;key == r2-&gt;key)\n            {\n                cout&lt;&lt; r1-&gt;key &lt;&lt; \" \";\n                s1.pop();\n                s2.pop();\n                root1 = root1-&gt;right;\n                root2 = root2-&gt;right;\n            }\n            else if (r1-&gt;key &lt; r2-&gt;key)\n            {\n                s1.pop();\n                r1 = r1-&gt;right;\n                r2 = NULL;\n            }\n            else if (r1-&gt;key &gt; r2-&gt;key)\n            {\n                s2.pop();\n                r2 = r2-&gt;right;\n                r1 = NULL;\n            }\n        }\n        else  break;\n    }\n}</code></pre>\n\n<p>Can you help Alice and Bob in finding the time complexity of the given code?</p>","a":[{"id":1649865,"option":"O(M*N)","correct":false},{"id":1649866,"option":"O(M+N)","correct":true},{"id":1649867,"option":"O(M)","correct":false},{"id":1649868,"option":"O(N)","correct":false}]},{"q":"<p>Bob loves trees and subtrees. While searching for a Binary Search Tree within a Binary Tree, he was very particular to find the BST which is of the maximum size, but he was confused about whether his method is efficient or not</p>\n\n<p>Here is the pseudocode he came up with.</p>\n\n<pre class=\"prettyprint\"><code>int function_find(node* node)\n{\n   int mini = INT_MAX; \n   int  maxi = INT_MIN; \n   int max_size = 0; \n   bool is_big = 0;\n   function_findut(node, &amp;min, &amp;max,&amp;max_size, &amp;is_big);\n   return max_size;\n}\nint function_findut(node* ref, int *min_ref, int *max_ref,\n                                 int *max_size_ref, bool *is_bst_ref)\n{\n    if (ref == NULL)\n    {\n        *is_bst_ref = 1;\n        return 0; \n    }\n    int min = INT_MAX;\n    bool left_f = false;\n    bool right_f = false;\n    int lbs, rbs; \n    *max_ref = INT_MIN;\n    lbs = function_findut(ref-&gt;left, min_ref, max_ref,\n                        max_size_ref, is_bst_ref);\n    if (*is_bst_ref == 1 &amp;&amp; ref-&gt;data &gt; *max_ref)\n        left_f = true;\n \n    min = *min_ref;\n    *min_ref = INT_MAX;\n    rbs = function_findut(ref-&gt;right, min_ref,\n                        max_ref, max_size_ref, is_bst_ref);\n    if (*is_bst_ref == 1 &amp;&amp; ref-&gt;data &lt; *min_ref)\n        right_f = true;\n    \n    if (min &lt; *min_ref)\n        *min_ref = min;\n    if (ref-&gt;data &lt; *min_ref) // For leaf nodes\n        *min_ref = ref-&gt;data;\n    if (ref-&gt;data &gt; *max_ref)\n        *max_ref = ref-&gt;data;\n   \n    if(left_f &amp;&amp; right_f)\n    {\n        if (lbs + rbs + 1 &gt; *max_size_ref)\n            *max_size_ref = lbs + rbs + 1;\n        return lbs + rbs + 1;\n    }\n    else\n    {\n        *is_bst_ref = 0;\n        return 0;\n    }\n}</code></pre>\n\n<p>Can you help Bob in finding the complexity of the given pseudocode ?</p>","a":[{"id":1649690,"option":"O(N)","correct":true},{"id":1649691,"option":"O(log n)","correct":false},{"id":1649692,"option":"O(n log n)","correct":false},{"id":1649693,"option":"O(N^2)","correct":false}]},{"q":"<p>Bob is very fond of watching mirror images. While solving a question in DSA he became very inquisitive about whether the two trees will be mirror images of each other or not. He was confused as various scenarios came into his mind. The following image depicts the two trees which are mirror images to each other.</p>\n\n<p style=\"text-align: center;\"><img alt=\"Lightbox\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/2009/06/MirrorTree1.GIF\"></p>\n\n<p>In order to check whether the two trees are mirror images of each other or not several conditions came to his mind but he was not sure which of them were correct. Will you help Bob in finding the conditions for the given problem?</p>\n\n<p><strong>Conditions</strong></p>\n\n<p>1. Their root node’s key must be the same</p>\n\n<p>2. Left subtree of the root of ‘a’ and right subtree root of ‘b’ are mirror</p>\n\n<p>3. Leaf nodes may not be the same</p>\n\n<p>4. Right subtree of ‘a’ and left subtree of ‘b’ are mirror</p>","a":[{"id":1648240,"option":"1, 2 and 4","correct":true},{"id":1648241,"option":"1, 2 and 3","correct":false},{"id":1648242,"option":"2, 3 and 4","correct":false},{"id":1648243,"option":"All of the above","correct":false}]},{"q":"<p>Alice loves to have challenges on trees while working on data structures and algorithms. She was given a number <em>N</em> which stated the length of the preorder sequence. She was then asked to count the number of binary trees possible from the given length <em>N</em>.</p>\n\n<p><strong>Example</strong></p>\n\n<p>Input: n = 1 Output: 1</p>\n\n<p>Input: n = 2 Output: 2</p>\n\n<p>Input: n = 3 Output: 5</p>\n\n<pre class=\"prettyprint\"><code>function_countTrees(N)\n  \n    DECLARE BT[n + 1]; // Array to store number of Binary tree for every count of nodes\n\n    memset(BT, 0, sizeof(BT)); //Intitializing elements of array with 0\n \n    INITIALIZE BT[0] = BT[1] = 1;\n \n    for i-&gt;2 to N\n        for j -&gt;0 to i\n           // LINE 7\n \n    return BT[n];</code></pre>\n\n<p>In the given pseudocode, what will come in place of Line 7?</p>\n\n<p><strong>Options</strong></p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>BT[i] += BT[j] * BT[i - j + 1];</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>BT[i] += BT[j] * BT[i - j - 1];</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>BT[i] += BT[j] * BT[i + j - 1];</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>BT[i] += BT[j] * BT[i + j + 1];</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":1648228,"option":"1","correct":false},{"id":1648229,"option":"2","correct":true},{"id":1648230,"option":"3","correct":false},{"id":1648231,"option":"4","correct":false}]},{"q":"<p>In Data Structures, you are working on Trees. You are given pseudocode that is used to find the <em>n<sup>th</sup></em> inorder node in a tree. You are required to execute the following pseudocode in a programing language.</p>\n\n<p><strong>Pseudocode</strong></p>\n\n<pre class=\"prettyprint\"><code>Nth_Inorder(struct Node* node, int n)\n{\n    COUNT = 0;\n    if (node == NULL)\n        return;\n \n    if count &lt;= n \n   {\n       //LINE 6\n        count++;\n        if COUNT == n\n           PRINT  node-&gt;data;\n\n      //LINE 7\n    }\n}</code></pre>\n\n<p>What will be the code inplace of line 6 and line 7?</p>\n\n<ol>\n\t<li>\n\t<pre class=\"prettyprint\"><code>Nth_Inorder(node-&gt;left,n)</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>Nth_Inorder(node-&gt;right,n)</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>Nth_Inorder(node-&gt;left-&gt;left,n)</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li>\n\t<pre class=\"prettyprint\"><code>Nth_Inorder(node-&gt;right-&gt;right,n)</code></pre>\n\n\t<p> </p>\n\t</li>\n</ol>","a":[{"id":1648172,"option":"1 then 2","correct":true},{"id":1648173,"option":"2 then 1","correct":false},{"id":1648174,"option":"3 then 2","correct":false},{"id":1648175,"option":"4 then 1","correct":false}]},{"q":"<p>What is the output of the following C++ code</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\nint key;\nHackNode *left, *right;\nHackNode(int val)\n{\n    key=val;\n    left=NULL;\n    right=NULL;\n}\n};\nbool HackPath(HackNode *root,vector&lt;HackNode *&gt;&amp;p1,int n){\n    if(root==NULL)\n        return false;\n    p1.push_back(root);\n    if(root-&gt;key==n)\n        return true;\n    if(HackPath(root-&gt;left,p1,n)||HackPath(root-&gt;right,p1,n))\n        return true;\n    p1.pop_back();\n    return false;   \n}\nHackNode *HackAncestor(HackNode *root,int n1,int n2){\n    vector&lt;HackNode *&gt;Hpath1,Hpath2;\n    if(HackPath(root,Hpath1,n1)==false || HackPath(root,Hpath2,n2)==false)\n        return NULL;\n    for(unsigned int i=0;i&lt;Hpath1.size()-1 &amp;&amp; i&lt;Hpath2.size()-1;i++)\n        if(Hpath1[i+1]!=Hpath2[i+1])\n        return Hpath1[i];\n        return NULL;\n}\nint main()\n{\n    HackNode *root=new HackNode(10);\n    root-&gt;left=new HackNode(20);\n    root-&gt;left-&gt;right=new HackNode(15);\n    root-&gt;right=new HackNode(30);\n    root-&gt;right-&gt;left=new HackNode(40);\n    root-&gt;right-&gt;right=new HackNode(50);\n    root-&gt;right-&gt;right-&gt;right=new HackNode(60);\n    HackNode *ancestor=HackAncestor(root,40,60);\n    cout&lt;&lt;ancestor-&gt;key;\n}</code></pre>\n\n<p> </p>","a":[{"id":1632661,"option":"20","correct":false},{"id":1632662,"option":"10","correct":false},{"id":1632663,"option":"30","correct":true},{"id":1632664,"option":"15","correct":false}]},{"q":"<p>What is the output of the following C++ code</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode\n{\n    char key;\n    HackNode *left;\n    HackNode *right;\n    HackNode(char val)\n    {\n        key = val;\n        left = NULL;\n        right = NULL;\n    }\n};\nint HackerEarth(HackNode *root)\n{\n    if (root == NULL)\n        return 0;\n    queue&lt;HackNode *&gt; HackQueue;\n    HackQueue.push(root);\n    int Hresult = 0;\n    while (!HackQueue.empty())\n    {\n        int count = HackQueue.size();\n        Hresult = max(Hresult, count);\n        for (int i = 0; i &lt; count; i++)\n        {\n            HackNode *curr = HackQueue.front();\n            HackQueue.pop();\n            if (curr-&gt;left != NULL)\n                HackQueue.push(curr-&gt;left);\n            if (curr-&gt;right != NULL)\n                HackQueue.push(curr-&gt;right);\n        }\n    }\n    return Hresult;\n}\nint main()\n{\n    HackNode *root = new HackNode(0);\n    root-&gt;left = new HackNode(1);\n    root-&gt;left-&gt;left = new HackNode(6);\n    root-&gt;left-&gt;right = new HackNode(3);\n    root-&gt;right = new HackNode(4);\n    root-&gt;right-&gt;left = new HackNode(2);\n    root-&gt;right-&gt;right = new HackNode(5);\n    root-&gt;right-&gt;right-&gt;right = new HackNode(9);\n    root-&gt;right-&gt;right-&gt;right-&gt;left = new HackNode(8);\n    root-&gt;right-&gt;right-&gt;right-&gt;right = new HackNode(7);\n    cout &lt;&lt; HackerEarth(root);\n}</code></pre>\n\n<p> </p>","a":[{"id":1632569,"option":"2","correct":false},{"id":1632570,"option":"1","correct":false},{"id":1632571,"option":"4","correct":true},{"id":1632572,"option":"3","correct":false}]},{"q":"<p>What is the output of the following C++ code</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode\n{\n    char key;\n    HackNode *left;\n    HackNode *right;\n    HackNode(char val)\n    {\n        key = val;\n        left = NULL;\n        right = NULL;\n    }\n};\nvoid HackPrint(HackNode *root){\n    if (root == NULL)\n        return;\n    stack&lt;HackNode *&gt; HackStack;\n    HackNode *curr = root;\n    while (curr != NULL || HackStack.empty() == false){\n        while (curr != NULL){\n            cout &lt;&lt; (int)(curr-&gt;key) &lt;&lt; \" \";\n            if (curr-&gt;right != NULL)\n                HackStack.push(curr-&gt;right);\n            curr = curr-&gt;left;\n        }\n        if (HackStack.empty() == false){\n            curr = HackStack.top();\n            HackStack.pop();\n        }\n    }\n}\nint main()\n{\n    HackNode *root = new HackNode('q');\n    root-&gt;left = new HackNode('w');\n    root-&gt;right = new HackNode('e');\n    root-&gt;right-&gt;left = new HackNode('r');\n    root-&gt;right-&gt;right = new HackNode('t');\n    root-&gt;right-&gt;right-&gt;right = new HackNode('y');\n    root-&gt;right-&gt;right-&gt;right-&gt;left = new HackNode('u');\n    root-&gt;right-&gt;right-&gt;right-&gt;right = new HackNode('i');\n    HackPrint(root);\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>119 113 104 101 116 121 117 105</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>113 119 101 114 116 121 117 105</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>119 113 104 101 116 121 117 105</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>113 119 101 104 116 121 117 105</code></pre>","a":[{"id":1632561,"option":"1","correct":false},{"id":1632562,"option":"2","correct":true},{"id":1632563,"option":"3","correct":false},{"id":1632564,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\n    int value;\n    struct HackNode *left, *right;\n};\nHackNode *newHackNode(int value){\n    HackNode *hack = new HackNode;\n    hack-&gt;value = value;\n    hack-&gt;left = hack-&gt;right = NULL;\n    return hack;\n}\nvoid printHackerTree(HackNode *root, int hd, map&lt;int, int&gt;&amp;HackMap){\n    if(root==NULL)\n    return;\n    printHackerTree(root-&gt;left, hd-1, HackMap);\n    HackMap[hd]+=root-&gt;value;\n    printHackerTree(root-&gt;right, hd+1, HackMap);\n}\nint main(){\n    HackNode *root = newHackNode(100);\n    root-&gt;left = newHackNode(80);\n    root-&gt;right = newHackNode(90);\n    root-&gt;left-&gt;left = newHackNode(70);\n    root-&gt;left-&gt;right = newHackNode(60);\n    root-&gt;left-&gt;left = newHackNode(50);\n    root-&gt;left-&gt;left-&gt;left = newHackNode(30);\n    root-&gt;left-&gt;right-&gt;right = newHackNode(40);\n    root-&gt;left-&gt;right-&gt;right-&gt;right = newHackNode(60);\n    map&lt;int, int&gt;HackMap;\n    printHackerTree(root, 0, HackMap);\n    for(auto it:HackMap)\n        cout&lt;&lt;it.second&lt;&lt;\" \";\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>30 50 80 160 130 80</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>40 35 15 30 100 80</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>30 50 80 160 130 60 </code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>40 50 80 160 130 60</code></pre>","a":[{"id":1632253,"option":"1","correct":false},{"id":1632254,"option":"2","correct":false},{"id":1632255,"option":"3","correct":true},{"id":1632256,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\n    int value;\n    struct HackNode *left, *right;\n};\nHackNode *newHackNode(int value){\n    HackNode *hack = new HackNode;\n    hack-&gt;value = value;\n    hack-&gt;left = hack-&gt;right = NULL;\n    return hack;\n}\nvoid printHackerTree(HackNode *root){\n    map&lt;int, int&gt;HackMap;\n    queue&lt;pair&lt;HackNode *, int&gt;&gt;HackQueue;\n    HackQueue.push({root, 0});\n    while(HackQueue.empty()==false){\n        auto hack=HackQueue.front();\n        int hd=hack.second;\n        HackNode *curr=hack.first;\n        if(HackMap.count(hd)==0)\n        HackMap[hd]=curr-&gt;value;\n        if(curr-&gt;left!=NULL)\n        HackQueue.push(make_pair(curr-&gt;left, hd-1));\n        if(curr-&gt;right!=NULL)\n        HackQueue.push(make_pair(curr-&gt;right, hd+1));\n        HackQueue.pop();\n    }\n    for(auto it:HackMap)\n        cout&lt;&lt;it.second&lt;&lt;\" \";\n}\nint main(){\n    HackNode *root = newHackNode(100);\n    root-&gt;left = newHackNode(80);\n    root-&gt;right = newHackNode(90);\n    root-&gt;left-&gt;right = newHackNode(70);\n    root-&gt;right-&gt;left = newHackNode(60);\n    root-&gt;left-&gt;right-&gt;left = newHackNode(50);\n    root-&gt;right-&gt;left-&gt;left = newHackNode(40);\n    root-&gt;left-&gt;right-&gt;left-&gt;left = newHackNode(30);\n    root-&gt;right-&gt;left-&gt;left-&gt;left = newHackNode(20);\n    printHackerTree(root);\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>20 80 100 90</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>30 80 100 90</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>30 50 100 90</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>20 50 100 90</code></pre>","a":[{"id":1632105,"option":"1","correct":false},{"id":1632106,"option":"2","correct":true},{"id":1632107,"option":"3","correct":false},{"id":1632108,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\n    char value;\n    struct HackNode *left, *right;\n};\nHackNode *newHackNode(char value){\n    HackNode *hack = new HackNode;\n    hack-&gt;value = value;\n    hack-&gt;left = hack-&gt;right = NULL;\n    return hack;\n}\nvoid printHackerTree(HackNode *root){\n    map&lt;int, char&gt;HackMap;\n    queue&lt;pair&lt;HackNode *, int&gt;&gt;HackQueue;\n    HackQueue.push({root, 0});\n    while(HackQueue.empty()==false){\n        auto hack=HackQueue.front();\n        int hd=hack.second;\n        HackNode *curr=hack.first;\n        if(HackMap.count(hd)==0)\n        HackMap[hd]=curr-&gt;value;\n        if(curr-&gt;left!=NULL)\n        HackQueue.push(make_pair(curr-&gt;left, hd-1));\n        if(curr-&gt;right!=NULL)\n        HackQueue.push(make_pair(curr-&gt;right, hd+1));\n        HackQueue.pop();\n    }\n    for(auto it:HackMap)\n        cout&lt;&lt;it.second&lt;&lt;\" \";\n}\nint main(){\n    HackNode *root = newHackNode('A');\n    root-&gt;left = newHackNode('B');\n    root-&gt;right = newHackNode('C');\n    root-&gt;left-&gt;left = newHackNode('D');\n    root-&gt;left-&gt;right = newHackNode('E');\n    root-&gt;right-&gt;left = newHackNode('F');\n    root-&gt;right-&gt;right = newHackNode('G');\n    printHackerTree(root);\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>D B F C G </code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>D C F B G</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>D C A B G</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>D B A C G</code></pre>","a":[{"id":1632101,"option":"1","correct":false},{"id":1632102,"option":"2","correct":false},{"id":1632103,"option":"3","correct":false},{"id":1632104,"option":"4","correct":true}]},{"q":"<p>What is the output of the following C++ code.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode\n{\n    char key;\n    HackNode *left;\n    HackNode *right;\n    HackNode(char val)\n    {\n        key = val;\n        left = NULL;\n        right = NULL;\n    }\n};\nvoid PrintHackerEarth(HackNode *root)\n{\n    if (root == NULL)\n        return;\n    queue&lt;HackNode *&gt; HackQueue;\n    HackQueue.push(root);\n    HackQueue.push(NULL);\n    while (HackQueue.size() &gt; 1)\n    {\n        HackNode *hack = HackQueue.front();\n        HackQueue.pop();\n        if (hack == NULL)\n        {\n            cout &lt;&lt; endl;\n            HackQueue.push(NULL);\n            continue;\n        }\n        cout &lt;&lt; hack-&gt;key &lt;&lt; \" \";\n        if (hack-&gt;left != NULL)\n            HackQueue.push(hack-&gt;left);\n        if (hack-&gt;right != NULL)\n            HackQueue.push(hack-&gt;right);\n    }\n}\nint main()\n{\n    HackNode *root = new HackNode('!');\n    root-&gt;left = new HackNode('@');\n    root-&gt;right = new HackNode('#');\n    root-&gt;left-&gt;left = new HackNode('$');\n    root-&gt;left-&gt;right = new HackNode('%');\n    root-&gt;right-&gt;right = new HackNode('^');\n    root-&gt;right-&gt;right-&gt;left = new HackNode('&amp;');\n    root-&gt;right-&gt;right-&gt;right = new HackNode('(');\n    PrintHackerEarth(root);\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>!\n@ #\n$ % ^\n&amp; (</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>! \n@ $\n% # ^\n&amp; (\n</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>!\n# ^\n&amp; ( @\n$ %</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>None of these</code></pre>","a":[{"id":1631777,"option":"1","correct":true},{"id":1631778,"option":"2","correct":false},{"id":1631779,"option":"3","correct":false},{"id":1631780,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\n    char value;\n    struct HackNode *left, *right;\n};\nHackNode *newHackNode(char value){\n    HackNode *hack = new HackNode;\n    hack-&gt;value = value;\n    hack-&gt;left = hack-&gt;right = NULL;\n    return hack;\n}\nvoid printHackerTree(HackNode *root){\n    map&lt;int, char&gt;HackMap;\n    queue&lt;pair&lt;HackNode *, int&gt;&gt;HackQueue;\n    HackQueue.push({root, 0});\n    while(HackQueue.empty()==false){\n        auto hack=HackQueue.front();\n        int hd=hack.second;\n        HackNode *curr=hack.first;\n        HackMap[hd]=curr-&gt;value;\n        if(curr-&gt;left!=NULL)\n        HackQueue.push(make_pair(curr-&gt;left, hd-1));\n        if(curr-&gt;right!=NULL)\n        HackQueue.push(make_pair(curr-&gt;right, hd+1));\n        HackQueue.pop();\n    }\n    for(auto it:HackMap)\n        cout&lt;&lt;it.second&lt;&lt;\" \";\n}\nint main(){\n    HackNode *root = newHackNode('A');\n    root-&gt;left = newHackNode('B');\n    root-&gt;right = newHackNode('C');\n    root-&gt;left-&gt;left = newHackNode('D');\n    root-&gt;left-&gt;right = newHackNode('E');\n    root-&gt;right-&gt;left = newHackNode('F');\n    root-&gt;right-&gt;right = newHackNode('G');\n    printHackerTree(root);\n}</code></pre>\n\n<p><strong>Output</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>D B F C G </code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>D B E C G</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>D C F B G</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>D B A C G</code></pre>\n\n<p> </p>","a":[{"id":1631769,"option":"1","correct":true},{"id":1631770,"option":"2","correct":false},{"id":1631771,"option":"3","correct":false},{"id":1631772,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode\n{\n    int key;\n    HackNode *left;\n    HackNode *right;\n    HackNode(int val)\n{\n        key = val;\n        left = NULL;\n        right = NULL;\n    }\n};\nvoid PrintHacker(HackNode *root, int k)\n{\nif (root == NULL)\n        return;\n    if (k == 0)\n        cout &lt;&lt; root-&gt;key &lt;&lt; \" \";\n    else\n    {\n        PrintHacker(root-&gt;left, k - 2);\n        PrintHacker(root-&gt;right, k - 1);\n    }\n}\nint main()\n{\n    HackNode *root = new HackNode(10);\n    root-&gt;left = new HackNode(5);\n    root-&gt;right = new HackNode(25);\n    root-&gt;left-&gt;left = new HackNode(2);\n    root-&gt;left-&gt;right = new HackNode(8);\n    root-&gt;right-&gt;right = new HackNode(40);\n    root-&gt;right-&gt;right-&gt;right = new HackNode(45);\n    PrintHacker(root, 2);\n}</code></pre>\n\n<p><strong>Output:</strong></p>\n\n<p><strong>1.</strong></p>\n\n<pre class=\"prettyprint\"><code>8 40</code></pre>\n\n<p><strong>2.</strong></p>\n\n<pre class=\"prettyprint\"><code>8 25</code></pre>\n\n<p><strong>3.</strong></p>\n\n<pre class=\"prettyprint\"><code>5 40</code></pre>\n\n<p><strong>4.</strong></p>\n\n<pre class=\"prettyprint\"><code>5 25</code></pre>","a":[{"id":1631773,"option":"1","correct":false},{"id":1631774,"option":"2","correct":false},{"id":1631775,"option":"3","correct":true},{"id":1631776,"option":"4","correct":false}]},{"q":"<p>What is the output of the following C++ code.</p>\n\n<p><strong>Code</strong></p>\n\n<pre class=\"prettyprint\"><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct HackNode{\n    int value;\n    struct HackNode *left, *right;\n};\nvector&lt;int&gt; HackTree(HackNode *root){\n    queue&lt;HackNode *&gt; hackQueue;\n    vector&lt;int&gt; vec;\n    if (root == NULL)\n        return vec;\n    hackQueue.push(root);\n    while (hackQueue.empty() == false){\n        HackNode *hack = hackQueue.front();\n        vec.push_back(hack-&gt;value);\n        hackQueue.pop();\n\n        if (hack-&gt;left != NULL)\n            hackQueue.push(hack-&gt;left);\n\n        if (hack-&gt;right != NULL)\n            hackQueue.push(hack-&gt;right);\n    }\n    return vec;\n}\nint hackVal(vector&lt;int&gt; result, int n){\n    vector&lt;int&gt; vec;\n    while (n &gt; 3){\n        int hackVal = floor(result[n - 1] * result[n - 2] /result[n - 3]);\n        vec.push_back(hackVal);\n        vec[0] += result[n - 4];\n        n = n - 4;\n    }\n    if (n == 3)\n        vec.push_back(result[2] * result[1] / result[0]);\n    if (n == 2)\n        vec.push_back(result[1] * result[0]);\n    if (n == 1)\n        vec.push_back(result[0]);\n    int ans = vec[0];\n    for (int i = 1; i &lt; vec.size(); i++)\n        ans -= vec[i];\n    return ans;\n}\nHackNode *newHackNode(int value){\n    HackNode *hack = new HackNode;\n    hack-&gt;value = value;\n    hack-&gt;left = hack-&gt;right = NULL;\n    return hack;\n}\nint main()\n{   HackNode *root = newHackNode(1);\n    root-&gt;left = newHackNode(2);\n    root-&gt;right = newHackNode(3);\n    root-&gt;left-&gt;left = newHackNode(4);\n    root-&gt;left-&gt;right = newHackNode(5);\n    root-&gt;right-&gt;left = newHackNode(7);\n    root-&gt;right-&gt;right = newHackNode(8);\n    vector&lt;int&gt; result;\n    result = HackTree(root);\n    int n = result.size();\n    int answer = hackVal(result, n);\n    cout &lt;&lt; answer &lt;&lt; \"\\n\";\n    return 0;\n}</code></pre>\n\n<p> </p>","a":[{"id":1631141,"option":"6","correct":false},{"id":1631142,"option":"5","correct":false},{"id":1631143,"option":"9","correct":true},{"id":1631144,"option":"12","correct":false}]},{"q":"<p>In Data Structures, if you are required to delete a node of a <strong>Red-Black Tree</strong> of <span class=\"mathjax-latex\">\\(n\\)</span> nodes, then determine its worst-case time complexity</p>","a":[{"id":1347194,"option":"O(n^n)","correct":false},{"id":1347195,"option":"O(n^2)","correct":false},{"id":1347196,"option":"O(log(n))","correct":true},{"id":1347197,"option":"O(n*log(n))","correct":false}]},{"q":"<p>In Data Structures, if you are working on a Binary Search Tree, then which of the following properties of this data structure are correct:</p>\n\n<ol>\n\t<li>The left subtree of a node contains only nodes with keys lesser than the node’s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys lesser than the node’s key.</li>\n\t<li>The left and right subtree each must also be a binary search tree.</li>\n</ol>","a":[{"id":1347182,"option":"1 and 2","correct":false},{"id":1347183,"option":"2 and 3","correct":false},{"id":1347184,"option":"1 and 3","correct":true},{"id":1347185,"option":"All of these","correct":false}]},{"q":"<p>In data structures, consider an unbalanced tree (not necessarily a Binary Tree) of n nodes.<br>\nYou create a tree using an adjacency matrix that has the representation of the tree (tree[][]) to update the weight of the n1<sup>th</sup> edge to n2 and print the maximum edge weight on the path from node n1 to node n2. <br>\nWhich of the following algorithms to set up the subtree size, depth, and parent for each node is most appropriate?</p>","a":[{"id":721322,"option":"Breadth First Search","correct":false},{"id":721323,"option":"Depth First Search","correct":true},{"id":721324,"option":"Maximum Flow","correct":false},{"id":721325,"option":"Minimum Spanning Tree","correct":false}]}]