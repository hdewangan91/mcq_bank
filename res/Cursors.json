[{"q":"<p>You observe that the most recent implicit cursor added to your PL/SQL block can be referred as the SQL cursor which has certain attributes. Which of these attributes will return TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows?</p>","a":[{"id":1618927,"option":"%FOUND","correct":true},{"id":1618928,"option":"%NOTFOUND","correct":false},{"id":1618929,"option":"%ROWCOUNT","correct":false},{"id":1618930,"option":"%BULK_ROWCOUNT","correct":false}]},{"q":"<p>Consider the following sequence of operations: - Explicit cursor is defined in PL/SQL block - Opening the cursor - Fetching the data Which of the following statements will hold true while performing the mentioned operations?</p>\n\n<p>A. Rows in the cursor can be fetched to a PL/SQL record created in the PL/SQL Block.</p>\n\n<p>B. If records are used, they can have a different structure to that of the cursor.</p>\n\n<p>C. If the list of variables are used, the variables must be listed in the same order in the fetch statement as the columns in the cursor</p>","a":[{"id":1618922,"option":"B","correct":false},{"id":1618923,"option":"B,C","correct":false},{"id":1618924,"option":"C","correct":false},{"id":1618925,"option":"A,C","correct":true}]},{"q":"<p>You notice that the CURSOR_CLOSE_ON_COMMIT has been set to OFF when issuing a rollback on a cursor. What will happen as a result of this?</p>","a":[{"id":1618914,"option":"ROLLBACK will close and deallocate all open cursors","correct":false},{"id":1618915,"option":"ROLLBACK will not affect any open synchronous STATIC or INSENSITIVE cursors","correct":true},{"id":1618916,"option":"ROLLBACK will affect the asynchronous STATIC cursors that have been fully populated","correct":false},{"id":1618917,"option":"Open cursors of any other type will be closed and deallocated","correct":false}]},{"q":"<p>You want to use a CURSOR FOR LOOP to perform some operations automatically. Which of the following actions can be achieved automatically in the given scenario?</p>\n\n<p>1. Implicitly declaring the loop index as a %rowtype record.</p>\n\n<p>2. Retrieve records for each iteration.</p>\n\n<p>3. Opening the cursor</p>","a":[{"id":1617112,"option":"Only 1 and 2","correct":false},{"id":1617113,"option":"Only 2 and 3","correct":false},{"id":1617114,"option":"Only 1 and 3","correct":false},{"id":1617115,"option":"All 1, 2 and 3","correct":true}]},{"q":"<p>Consider the syntax for FOR LOOP cursor statement given alongside. Which of the following statements can be deduced in the given context?</p>\n\n<p>S1: The declared cursor is set up in the FOR loop.</p>\n\n<p>S2: The loop variable 'I' will behave as a cursor variable.</p>\n\n<pre class=\"prettyprint\"><code>DECLARE\nCURSOR &lt;cursor_name&gt; IS &lt;SELECT statement&gt;;\nBEGIN\n FOR I IN &lt;cursor_name&gt;\n LOOP\n .\n .\n END LOOP;\nEND;</code></pre>\n\n<p> </p>","a":[{"id":1617108,"option":"Only S1","correct":false},{"id":1617109,"option":"Only S2","correct":false},{"id":1617110,"option":"Both S1 and S2","correct":true},{"id":1617111,"option":"Neither S1 nor S2","correct":false}]},{"q":"<p>Assume that you have declared cursors in a procedure and a package specification. Which of the following options is valid in the given context?</p>","a":[{"id":1617098,"option":"Cursor declared in Package specification is Global","correct":false},{"id":1617099,"option":"Cursor declared in Procedure is restricted to that specific procedure","correct":false},{"id":1617100,"option":"Cursors declared in procedure can be invoked from other procedures too","correct":false},{"id":1617101,"option":"Both 1 and 2","correct":true}]},{"q":"<p>While writing a fetch query, you want to be sure to retrieve the first row in a cursor’s query results. Which fetch orientation option should you use in the FETCH statement in order to do so?</p>","a":[{"id":1617094,"option":"PRIOR","correct":false},{"id":1617095,"option":"NEXT","correct":false},{"id":1617096,"option":"ABSOLUTE -1","correct":false},{"id":1617097,"option":"FIRST","correct":true}]},{"q":"<p>You have a table <em>students</em> with columns id, name, and email. Which of these options is a correct way to declare a cursor for executing a SELECT query on the <em>students</em> table?</p>","a":[{"id":1617090,"option":"CURSOR c_students IS  SELECT id, name, email FROM students;","correct":true},{"id":1617091,"option":"CURSOR c_students SELECT id, name, email FROM students;","correct":false},{"id":1617092,"option":"CURSOR c_students FOR  SELECT id, name, email FROM students;","correct":false},{"id":1617093,"option":"OPEN CURSOR c_students SELECT id, name, email FROM students;","correct":false}]},{"q":"<p>You want to use cursor attributes to access some information about a certain cursor. Which of these attributes DOES NOT return a boolean value when doing so?</p>","a":[{"id":1617086,"option":"%FOUND","correct":false},{"id":1617087,"option":"%ROWCOUNT","correct":true},{"id":1617088,"option":"%OPENCOUNT","correct":false},{"id":1617089,"option":"%COUNT","correct":false}]},{"q":"<p>You want to declare an explicit cursor to control the context area when working with a PL/SQL block. Which of the following can be inferred from the given scenario?</p>\n\n<p>1. The name of this context area is the same as the cursor name.</p>\n\n<p>2. You are creating a named context area for the 'SELECT' statement that is defined in the declaration part.</p>","a":[{"id":1616918,"option":"Only 1","correct":false},{"id":1616919,"option":"Only 2","correct":false},{"id":1616920,"option":"Both 1 and 2","correct":true},{"id":1616921,"option":"Neither 1 nor 2","correct":false}]},{"q":"<p>You want to add cursors in your PL/SQL block such that programmers cannot control it and the information in it. Which of these types of cursors can you use to achieve this?</p>","a":[{"id":1616914,"option":"Implicit Cursors","correct":true},{"id":1616915,"option":"Explicit cursors","correct":false},{"id":1616916,"option":"Both 1 and 2","correct":false},{"id":1616917,"option":"Neither 1 nor 2","correct":false}]},{"q":"<p>You are using 'REF CURSOR' as the data type when declaring a cursor variable in PL/SQL. In the given scenario, which of these snippets can be used to create a strong typed REF CURSOR variable named 'e_employee'?</p>","a":[{"id":1619232,"option":"DECLARE TYPE employee_t IS REF CURSOR RETURN employees%ROWTYPE;  e_employee employee_t;","correct":true},{"id":1619233,"option":"DECLARE TYPE employee_t IS REF CURSOR;  e_employee employee_t;","correct":false},{"id":1619234,"option":"DECLARE e_employee SYS_REFCURSOR;","correct":false},{"id":1619235,"option":"All 1, 2 and 3","correct":false}]},{"q":"<p>Assume that you are using SQL cursor attributes in procedural statements but not in SQL statements. In the given scenario, what do the implicit cursor attributes return if Oracle opens the SQL cursor automatically?</p>","a":[{"id":1617103,"option":"It returns NULL","correct":true},{"id":1617104,"option":"It returns FALSE","correct":false},{"id":1617105,"option":"It returns TRUE","correct":false},{"id":1617106,"option":"It returns 1","correct":false}]},{"q":"<p>You want to use a cursor to control the context area. Which of the following statements doesn't have an implicit cursor associated with it when issued?</p>","a":[{"id":1618918,"option":"INSERT","correct":false},{"id":1618919,"option":"UPDATE","correct":false},{"id":1618920,"option":"DELETE","correct":false},{"id":1618921,"option":"DROP","correct":true}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following cursors is constructed and maintained by the user?</p>","a":[{"id":1139755,"option":"Implicit cursor","correct":false},{"id":1139756,"option":"Explicit cursor","correct":true},{"id":1139757,"option":"Both of these","correct":false},{"id":1139758,"option":"None of these","correct":false}]},{"q":"<p>You have fetched all records from an explicit cursor and closed the cursor. What will happen as a result of doing this?</p>","a":[{"id":1616922,"option":"The memory allocated to this context area will be released.","correct":true},{"id":1616923,"option":"A Boolean result 'TRUE' is returned.","correct":false},{"id":1616924,"option":"A Boolean result 'FALSE' is returned.","correct":false},{"id":1616925,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If an explicit cursor is not open, then which of the following predefined exception is raised by the explicit cursor attribute %ROWCOUNT?</p>","a":[{"id":1139803,"option":"NOT_OPEN_ERROR","correct":false},{"id":1139804,"option":"NOT_OPEN","correct":false},{"id":1139805,"option":"UNKNOWN_CURSOR","correct":false},{"id":1139806,"option":"INVALID_CURSOR","correct":true}]},{"q":"<p>In PL/SQL, you are declaring the cursor variable as a formal parameter of a subprogram. If the subprogram only fetches from the cursor variable, which of the following can be the parameter modes:<br>\n1. IN<br>\n2. OUT<br>\n3. IN OUT</p>","a":[{"id":1139843,"option":"Either 1 or 2","correct":false},{"id":1139844,"option":"Either 2 or 3","correct":false},{"id":1139845,"option":"Either 1 or 3","correct":true},{"id":1139846,"option":"Only 2","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to create a cursor variable, then which of the following types must be defined?</p>","a":[{"id":1139827,"option":"SYS_REFCURSOR type","correct":false},{"id":1139828,"option":"REF CURSOR type and defined variable with the cursor type.","correct":false},{"id":1139829,"option":"Either 1 or 2","correct":true},{"id":1139830,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following attributes of the implicit cursor are correct:<br>\n1. SQL%ISOPEN<br>\n2. SQL%ISCLOSE<br>\n3. SQL%FOUND<br>\n4. SQL%NOTFOUND</p>","a":[{"id":1139767,"option":"1, 2, and 3","correct":false},{"id":1139768,"option":"2, 3, and 4","correct":false},{"id":1139769,"option":"1, 2, and 4","correct":false},{"id":1139770,"option":"1, 3, and 4","correct":true}]},{"q":"<p>In PL/SQL, which of the following syntaxes about the REF CURSOR type definition is correct?</p>","a":[{"id":1139831,"option":"TYPE type_name IS REF CURSOR [ RETURN return_type ]","correct":true},{"id":1139832,"option":"TYPE type_name IS REF CURSOR { RETURN return_type }","correct":false},{"id":1139833,"option":"TYPE type_name AS REF CURSOR [ RETURN return_type ]","correct":false},{"id":1139834,"option":"TYPE type_name AS REF CURSOR { RETURN return_type }","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to fetch the rows of the query result set after opening an explicit cursor, then which of the following syntax is used to perform this action?</p>","a":[{"id":1139795,"option":"FETCH cursor_name","correct":false},{"id":1139796,"option":"FETCH cursor_name AS into_clause","correct":false},{"id":1139797,"option":"FETCH cursor_name LIKE into_clause","correct":false},{"id":1139798,"option":"FETCH cursor_name INTO into_clause","correct":true}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to determine the number of rows affected by the FORALL statement, then which of the following implicit cursor attributes is used to perform this action?</p>","a":[{"id":1139771,"option":"SQL%BULK_ROWCOUNT","correct":true},{"id":1139772,"option":"SQL%ROWCOUNT","correct":false},{"id":1139773,"option":"SQL%BULK_EXCEPTION","correct":false},{"id":1139774,"option":"SQL%BULK_ROW","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to determine the number of cursors that a session can have open simultaneously, then which of the following factors are required to perform this action:<br>\n1. The number of cursors that are used in a rollback transaction.<br>\n2. Amount of memory available for a session.<br>\n3. The value of the initialization parameter OPEN_CURSORS</p>","a":[{"id":1139759,"option":"1 and 2","correct":false},{"id":1139760,"option":"2 and 3","correct":true},{"id":1139761,"option":"1 and 3","correct":false},{"id":1139762,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following cursors is constructed and maintained by the PL/SQL?</p>","a":[{"id":1139751,"option":"Implicit cursor","correct":true},{"id":1139752,"option":"Explicit cursor","correct":false},{"id":1139753,"option":"Both of these","correct":false},{"id":1139754,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. If you are required to process the query result sets by using the cursors, then which of the following PL/SQL statements uses the explicit cursor:<br>\n1. OPEN<br>\n2. SELECT INTO<br>\n3. FOR LOOP<br>\n4. FETCH</p>","a":[{"id":1139811,"option":"1 and 2","correct":false},{"id":1139812,"option":"3 and 4","correct":false},{"id":1139813,"option":"2 and 3","correct":false},{"id":1139814,"option":"1 and 4","correct":true}]},{"q":"<p>In PL/SQL, you are working on the cursors. If an explicit cursor query includes a virtual column, then which of the following conditions must be true such that the column must have an alias feature:<br>\n1. The cursor is used to fetch into a record that was declared with %ROWTYPE.<br>\n2. The cursor is used to store the session record that was invoked with %ROW_SIZE.</p>","a":[{"id":1139799,"option":"1","correct":true},{"id":1139800,"option":"2","correct":false},{"id":1139801,"option":"Both of these","correct":false},{"id":1139802,"option":"None of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursors. Which of the following statements about the explicit cursor are correct:<br>\n1. This cursor is defined and declared by giving it a name and associating it with a query.<br>\n2. This cursor is used in a cursor FOR LOOP statement to process the query result set.<br>\n3. A value cannot be assigned to this cursor by using the value as in expression.</p>","a":[{"id":1139787,"option":"1 and 2","correct":true},{"id":1139788,"option":"2 and 3","correct":false},{"id":1139789,"option":"1 and 3","correct":false},{"id":1139790,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on working on the cursors. Which of the following statements about the implicit cursor are correct:<br>\n1. PL/SQL opens an implicit cursor every time you run a SELECT or DML statement.<br>\n2. SQLattribute always refers to the least recently run SELECT or DML statement.<br>\n3. If no DML is executed, then the value of the SQLattribute is NULL</p>","a":[{"id":1139763,"option":"1 and 2","correct":false},{"id":1139764,"option":"2 and 3","correct":false},{"id":1139765,"option":"1 and 3","correct":true},{"id":1139766,"option":"All of these","correct":false}]},{"q":"<p>In PL/SQL, you are working on the cursor variables. If you have assigned a value of the cursor variable VAR1 to another cursor variable VAR2, then which of the following statements in this scenario is correct:<br>\n1. If VAR1 is not open, then after the assignment, VAR2 is still open.<br>\n2. If VAR1 is open, opening VAR2 after the assignment does not open VAR1.</p>","a":[{"id":1139835,"option":"1","correct":false},{"id":1139836,"option":"2","correct":false},{"id":1139837,"option":"Both of these","correct":false},{"id":1139838,"option":"None of these","correct":true}]}]